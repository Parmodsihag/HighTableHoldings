# main.py
# import time
# st = time.time()
import os
import tkinter as tk
from tkinter import ttk, PhotoImage
from datetime import datetime

# Import color definitions and themes
from gui.mytheme import Colors, Colors1 

# Import your GUI classes (adjust the paths if necessary)
from gui.homepage import HomePage 
from gui.sales import SalesPage
from gui.accounts import AccountPage
from gui.items import AddItemsPage 
from gui.karar import KararPage
from gui.reports import ReportsPage
from gui.modify import ModifyPage
from gui.crop_trading import CropTradingPage 

# Import any necessary utility functions
from mypandasfile import get_all_list

# Import database modules needed for initialization check
from database import crop_database, accounts, inventory, database, krar


class CustomLabel(tk.Frame):
    def __init__(self, master, text, frame_to_link, x, **kwargs):
        super().__init__(master, highlightbackground=Colors.ACTIVE_FOREGROUND, **kwargs)
        self.customlabel = tk.Label(self, text=text, font=("Consolas", 14), anchor="e")#, pady=10, highlightthickness=0, padx=20, pady=10, anchor="w", highlightthickness=0, highlightbackground=Colors.ACTIVE_FOREGROUND)
        self.customlabel.pack(fill='both', side="right", expand=1)

        self.customlabel1 = tk.Label(self, text="", font=("Consolas", 20), anchor='w')
        self.customlabel1.pack(side='left',fill='x')#, expand=1)

        self.frame1 = frame_to_link
        self.bind("<Enter>", self.on_enter)
        self.bind("<Leave>", self.on_leave)
        self.customlabel.bind("<Button-1>", self.on_click)
        self.customlabel1.bind("<Button-1>", self.on_click)

        # self.Colors = Colors
        
        self.normal_bg = Colors.BACKGROUND1
        self.normal_fg = Colors.FOREGROUND
        self.hover_bg = Colors.LIGHT_BG
        self.hover_fg = Colors.FOREGROUND
        self.active_bg = Colors.ACTIVE_BACKGROUND
        self.active_fg = Colors.FG_SHADE_1
        
        self.is_active = False
        self.is_hovering = False
        self.customlabel.configure(background=self.normal_bg, foreground=self.normal_fg)
        self.customlabel1.configure(background=self.normal_bg)
        self.master.master.bind(f"<Alt-{x}>", self.alt_key)  # Bind Alt + x key
        self.x = x
        # print(self.x)

    def alt_key(self, event):
        # print(event.char.isdigit())
        if event.char == self.x:
            self.on_click(event)

        # if event.char.isdigit():
        #     key_pressed = int(event.char)
        #     print(key_pressed, self.x, key_pressed== self.x)
        #     if key_pressed == self.x:
        #         self.on_click(event)

        
    def on_enter(self, event):
        if not self.is_active:
            self.customlabel.configure(background=self.hover_bg, foreground=self.hover_fg)
            self.customlabel1.configure(background=self.hover_bg, foreground=self.hover_fg)
            self.is_hovering = True
            
    def on_leave(self, event):
        if not self.is_active:
            self.customlabel.configure(background=self.normal_bg, foreground=self.normal_fg)
            self.customlabel1.configure(background=self.normal_bg, foreground=self.normal_fg)
            self.is_hovering = False
            
    def on_click(self, event):
        # print('click')
        for  i in self.master.winfo_children():
            # print('clicksdf')
            i.set_inactive()
    
        self.is_active = True
        self.is_hovering = False
        self.customlabel.configure( foreground=self.active_fg)#, relief='solid')
        self.customlabel1.configure( background=self.active_fg)#, relief='solid')
        self.frame1.tkraise()
        
    def set_inactive(self):
        self.is_active = False
        self.is_hovering = False
        self.customlabel.configure(background=self.normal_bg, foreground=self.normal_fg)
        self.customlabel1.configure(background=self.normal_bg)

    def set_active(self):
        self.is_active = True
        self.is_hovering = False
        self.customlabel.configure(foreground=self.active_fg)#, relief='solid')
        self.customlabel1.configure(background=self.active_fg)#, relief='solid')
        self.frame1.tkraise()



class MyApp(tk.Tk):

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.create_folder_and_subfolder()
        crop_database.initialize_database()
        self.themeint = 0
        self.is_graph_ready = 0
        self.title("High Table Holdings")
        self.state("zoomed")
        # self.config(background=Colors.BACKGROUND1)
        # self.clrs = Colors
        # img = tk.PhotoImage(file="myicons\\framebg2.png")

        # self.background_title = tk.Label(self, image=img)
        # self.background_title.place(relx=0, rely=0, relheight=1, relwidth=1)

        # self.img = img

        self.style=ttk.Style()
        self.style.theme_create('mytheme', parent='default', 
                        settings={
                            # 'TCombobox':
                            # {
                            #     'configure':
                            #     {
                            #     # 'arrowsize': 12,
                            #     'font':"Consolas 14",
                            #     'relief':'flat'
                            #     }
                            # },
                            'Treeview':{
                                'configure':
                                {
                                    'rowheight': 28,
                                    'font': 'Ubantu 10'
                                }
                            }
                        }
                    )
        # self.style.theme_use('mytheme')
        # self.style.configure('TCombobox', selectbackground=Colors.FG_SHADE_1, 
        #                     fieldbackground=Colors.BACKGROUND, 
        #                     background=Colors.BACKGROUND, 
        #                     foreground=Colors.FG_SHADE_1, 
        #                     arrowcolor=Colors.FOREGROUND,
        #                     borderwidth=1)
        # self.style.configure('Treeview', fieldbackground=Colors.BACKGROUND, font="Consolas 18", rowheight=35)
        # self.style.configure("Treeview.Heading", foreground=Colors.FOREGROUND, background=Colors.BACKGROUND1, font='Consolas 14')

        self.style.configure('Treeview', fieldbackground=Colors.BACKGROUND, font="Consolas 18", rowheight=35)
        self.style.configure("Treeview.Heading", foreground=Colors.FOREGROUND, background=Colors.BACKGROUND1, font='Consolas 14')
        # Configure TCombobox style explicitly here or in toggle_theme
        self.style.map('TCombobox', fieldbackground=[('readonly', Colors.BACKGROUND3)]) # Example for readonly state
        self.style.map('TCombobox', foreground=[('readonly', Colors.FG_SHADE_1)])
        self.style.map('TCombobox', selectbackground=[('readonly', Colors.ACTIVE_BACKGROUND)])
        self.style.map('TCombobox', selectforeground=[('readonly', Colors.ACTIVE_FOREGROUND)])



        # self.chatbot_instance = None


        # main 4 parts 
        self.title_bar = tk.Frame(self, bg=Colors.BG_SHADE_1)
        self.title_bar.place(relx=0, rely=0, relheight=0.04, relwidth=1)

        self.menu_frame = tk.Frame(self, bg=Colors.BACKGROUND1)
        self.menu_frame.place(relx=0.005, rely=0.255, relheight=0.675, relwidth=0.095)
        self.action_frame = tk.Frame(self, bg=Colors.BACKGROUND1)
        self.action_frame.place(relx=0.1, rely=0.04, relheight=0.9, relwidth=0.9)
        self.status_bar = tk.Frame(self, bg=Colors.BG_SHADE_1)
        self.status_bar.place(relx=0, rely=0.94, relheight=0.06, relwidth=1)


        
        # logo
        self.logo_frame = tk.Frame(self)
        self.logo_frame.place(relx=0.005, rely=0.05, relheight=0.2, relwidth=0.095)
        self.logo_image = PhotoImage(file="myicons/logos.png")
        logo_image_label = tk.Label(self.logo_frame, image=self.logo_image, background=Colors.BACKGROUND1)
        logo_image_label.pack( fill="both", expand=1)
        
        # img = tk.PhotoImage(file="myicons\\framebg2.png")

        # self.background_title = tk.Label(self.logo_frame, image=img)
        # self.background_title.place(relx=0, rely=0, relheight=1, relwidth=1)

        # self.img = img

        self.title_bar_f(self.title_bar)
        
        self.status = tk.StringVar()
        self.statusl = tk.Label(self.status_bar, textvariable=self.status, font="Consolas 18", background=Colors.BG_SHADE_1, fg=Colors.ACTIVE_FOREGROUND)
        self.statusl.pack(anchor="e")
        self.status.set("|Status Bar|")
        

        # adding other views frames
        # self.homeframe = tk.Frame(self.action_frame, bg=Colors.ACTIVE_BACKGROUND)
        self.homeframe = HomePage(self.action_frame)
        self.homeframe.place(relx=0, rely=0, relheight=1, relwidth=1)
        self.saleframe = SalesPage(self.action_frame)
        self.saleframe.place(relx=0, rely=0, relheight=1, relwidth=1)
        self.accountframe = AccountPage(self.action_frame)
        self.accountframe.place(relx=0, rely=0, relheight=1, relwidth=1)
        self.additemframe = AddItemsPage(self.action_frame)
        self.additemframe.place(relx=0, rely=0, relheight=1, relwidth=1)
        self.kararframe = KararPage(self.action_frame)
        self.kararframe.place(relx=0, rely=0, relheight=1, relwidth=1)
        self.reportframe = ReportsPage(self.action_frame)
        self.reportframe.place(relx=0, rely=0, relheight=1, relwidth=1)
        self.modifyframe = ModifyPage(self.action_frame)
        self.modifyframe.place(relx=0, rely=0, relheight=1, relwidth=1)
        
        # self.croptradeframe = CropTradingPage(self.action_frame) # <--- Create Crop Trading Frame
        # self.croptradeframe.place(relx=0, rely=0, relheight=1, relwidth=1)
        # self.billframe = BillPage(self.action_frame)
        # self.billframe.place(relx=0, rely=0, relheight=1, relwidth=1)
        # self.billshowframe = BillShowPage(self.action_frame)
        # self.billshowframe.place(relx=0, rely=0, relheight=1, relwidth=1)

        # adding labels in menu
        # self.home_page_label = CustomFrame(self.menu_frame, "Home",self.homeframe)
        # self.home_page_label.pack( fill="x")
        # self.sale_page_label = CustomFrame(self.menu_frame, "Sale", self.saleframe)
        # self.sale_page_label.pack( fill="x")
        self.home_page_label = CustomLabel(self.menu_frame, "Home ",self.homeframe, "H")
        self.home_page_label.pack( fill="x")
        self.sale_page_label = CustomLabel(self.menu_frame, "Sale ", self.saleframe, "S")
        self.sale_page_label.pack( fill="x")
        self.account_page_label = CustomLabel(self.menu_frame, "Account ", self.accountframe, 'A')
        self.account_page_label.pack( fill="x")
        self.add_item_page_label = CustomLabel(self.menu_frame, "Items ", self.additemframe, 'I')
        self.add_item_page_label.pack( fill="x")
        self.karar_frame_label = CustomLabel(self.menu_frame, "Karar ", self.kararframe, 'K')
        self.karar_frame_label.pack( fill="x")
        self.modify_frame_label = CustomLabel(self.menu_frame, "Modify ", self.modifyframe, 'M')
        self.modify_frame_label.pack( fill="x")
        self.report_frame_label = CustomLabel(self.menu_frame, "Reports ", self.reportframe, 'R')
        self.report_frame_label.pack( fill="x")
        # self.crop_trading_label = CustomLabel(self.menu_frame, "Crop Trade ", self.croptradeframe, 'C') # <--- Add Label
        # self.crop_trading_label.pack( fill="x") # <--- Pack it
        # self.bill_frame_label = CustomLabel(self.menu_frame, "Bills ", self.billframe, 'B')
        # self.bill_frame_label.pack( fill="x")
        # self.bill_show_frame_label = CustomLabel(self.menu_frame, "Bill ", self.billshowframe, 'T')
        # self.bill_show_frame_label.pack( fill="x")

        self.bind()
        # activating home page
        self.home_page_label.set_active()

        # self.sale_page_label.set_active()
        # self.account_page_label.set_active()
        # self.report_frame_label.set_active()
        # self.modify_frame_label.set_active()
        # self.karar_frame_label.set_active()

        # data_process = multiprocessing.Process(target=self.my_parallel_processes, args=(1,2))
        # data_process.start()

        # data_process.join()

    def create_folder_and_subfolder(self):
        """Creates the folder JBB in the C drive and a subfolder named data,
        if they don't already exist.
        """

        folder_path = "C:/JBB"
        subfolder_path_data = os.path.join(folder_path, "data")
        subfolder_path_bills = os.path.join(folder_path, "bills")
        subfolder_path_pdfs = os.path.join(folder_path, "pdfs")
        subfolder_path_merged_pdfs = os.path.join(folder_path, "merged_pdfs")

        try:
            os.makedirs(folder_path, exist_ok=True)  # Create parent folders if needed
            os.makedirs(subfolder_path_data, exist_ok=True)  # Create parent folders if needed
            os.makedirs(subfolder_path_bills, exist_ok=True)  # Create parent folders if needed
            os.makedirs(subfolder_path_pdfs, exist_ok=True)  # Create parent folders if needed
            os.makedirs(subfolder_path_merged_pdfs, exist_ok=True)  # Create parent folders if needed
            # print(f"Folder structure created successfully: {subfolder_path}")
        except OSError as e:
            print(f"Error creating folder structure: {e}")

    def title_bar_f(self, master):
        today = datetime.now().strftime('%d %m|%Y')
        company_name = tk.Label(master, text="JAAT BEAJ BHANDER", font="Consolas 16", bg= Colors.BG_SHADE_1, fg=Colors.FG_SHADE_3)
        company_name.place(relx=0.01, rely=0)
        today_date = tk.Label(master, text=today, font="Consolas 16", bg= Colors.BG_SHADE_1, fg=Colors.FG_SHADE_1)
        today_date.place(relx=0.9, rely=0)

        show_graph_label = tk.Label(master, text="📊", font="Consolas 16", bg= Colors.BG_SHADE_1, fg=Colors.FG_SHADE_1)
        show_graph_label.place(relx=0.8, rely=0)
        show_graph_label.bind("<Button-1>",lambda e: self.my_parallel_processes())

        change_theme_label = tk.Label(master, text="🎨", font="Consolas 16", bg= Colors.BG_SHADE_1, fg=Colors.FG_SHADE_1)
        change_theme_label.place(relx=0.78, rely=0)
        change_theme_label.bind("<Button-1>",lambda e: self.togle_theme())

    # ---Function to show/hide chatbot ---
    
    def set_status(self,s):
        self.status.set(s)

    def togle_theme(self):
        # ... (your theme toggling logic) ...
        global Colors # Make sure Colors is updated globally if needed by other modules
        if self.themeint:
            Colors = Colors1 # Use Colors1 instance directly
            self.themeint = 0
        else:
            Colors = Colors # Use Colors instance directly
            self.themeint = 1

        # Update styles and widgets recursively
        self.update_widget_colors(self, Colors) # Pass the selected theme instance
        # Update specific pages if they cache Colors
        self.homeframe.Colors = Colors
        self.reportframe.Colors = Colors
        # self.chatbotpage.Colors = Colors # If ChatbotPage uses self.Colors

        # Update styles
        self.style.configure('Treeview', fieldbackground=Colors.BACKGROUND)
        self.style.configure("Treeview.Heading", foreground=Colors.FOREGROUND, background=Colors.BACKGROUND1)
        self.style.map('TCombobox', fieldbackground=[('readonly', Colors.BACKGROUND3)])
        self.style.map('TCombobox', foreground=[('readonly', Colors.FG_SHADE_1)])
        self.style.map('TCombobox', selectbackground=[('readonly', Colors.ACTIVE_BACKGROUND)])
        self.style.map('TCombobox', selectforeground=[('readonly', Colors.ACTIVE_FOREGROUND)])

        if self.is_graph_ready:
            self.homeframe.redraw_graphs()


    def update_widget_colors(self, widget, colors):
        # ... (your recursive color update logic) ...
        # Ensure it handles all widget types correctly based on the 'colors' object passed in
        widget_bg = colors.BACKGROUND
        widget_fg = colors.FOREGROUND
        active_bg = colors.ACTIVE_BACKGROUND
        active_fg = colors.ACTIVE_FOREGROUND
        entry_bg = colors.BACKGROUND3
        entry_fg = colors.FG_SHADE_1
        button_fg = colors.FG_SHADE_3
        label_fg = colors.ACTIVE_FOREGROUND # Or colors.FOREGROUND depending on label type

        config_opts = {}

        # --- Frame / Toplevel ---
        if isinstance(widget, (tk.Frame, tk.Toplevel, tk.PanedWindow)):
             config_opts['bg'] = widget_bg

        # --- Label ---
        elif isinstance(widget, tk.Label):
             # Be careful not to override labels meant to stay a specific color (like titles)
             # Maybe check current bg/fg before changing?
             # Simple approach: change all non-title-bar labels
             if widget.master != self.title_bar and widget.master != self.status_bar:
                  config_opts['background'] = widget_bg
                  # Decide on foreground based on role, default to standard FG
                  config_opts['foreground'] = label_fg if widget.cget('foreground') != colors.FG_SHADE_3 else colors.FG_SHADE_3

        # --- Button ---
        elif isinstance(widget, tk.Button):
             config_opts['background'] = widget_bg # Or BACKGROUND1/3?
             config_opts['foreground'] = button_fg
             config_opts['activebackground'] = active_bg
             config_opts['activeforeground'] = colors.BACKGROUND # Often white/black on active

        # --- Entry ---
        elif isinstance(widget, tk.Entry):
             config_opts['background'] = entry_bg
             config_opts['foreground'] = entry_fg
             config_opts['relief'] = 'solid' # Ensure relief matches theme
             config_opts['bd'] = 1
             config_opts['insertbackground'] = colors.FOREGROUND # Cursor

        # --- Text / ScrolledText ---
        # elif isinstance(widget, (tk.Text, scrolledtext.ScrolledText)):
        #      config_opts['background'] = entry_bg # Often same as Entry
        #      config_opts['foreground'] = entry_fg
        #      config_opts['insertbackground'] = colors.FOREGROUND # Cursor

        # --- Listbox ---
        elif isinstance(widget, tk.Listbox):
             config_opts['background'] = entry_bg
             config_opts['foreground'] = entry_fg
             config_opts['selectbackground'] = active_bg
             config_opts['selectforeground'] = colors.FOREGROUND

        # --- ttk Widgets (Check style configuration first) ---
        elif isinstance(widget, ttk.Combobox):
             # Primarily handled by style, but might set readonly bg/fg if needed
             pass # Rely on self.style updates
        elif isinstance(widget, ttk.Treeview):
             pass # Rely on self.style updates
        elif isinstance(widget, ttk.Scrollbar):
             # Often themed with parent, but might need explicit config
             pass

        # --- Custom Widgets ---
        elif isinstance(widget, CustomLabel):
             widget.normal_bg = colors.BACKGROUND1
             widget.normal_fg = colors.FOREGROUND
             widget.hover_bg = colors.LIGHT_BG
             widget.hover_fg = colors.FOREGROUND
             widget.active_bg = colors.ACTIVE_BACKGROUND
             widget.active_fg = colors.FG_SHADE_1
             # Re-apply current state colors
             if widget.is_active:
                  widget.customlabel.config(fg=widget.active_fg) # Keep bg as frame's bg
                  widget.customlabel1.config(bg=widget.active_fg) # Frame bg remains default
             elif widget.is_hovering:
                  widget.customlabel.config(bg=widget.hover_bg, fg=widget.hover_fg)
                  widget.customlabel1.config(bg=widget.hover_bg)
             else:
                  widget.customlabel.config(bg=widget.normal_bg, fg=widget.normal_fg)
                  widget.customlabel1.config(bg=widget.normal_bg)
             # Configure the frame itself
             config_opts['bg'] = widget_bg # Set frame background

        # Apply collected configurations
        if config_opts:
             try:
                  widget.configure(**config_opts)
             except tk.TclError as e:
                  # Ignore errors for widgets that don't support certain options (like 'bg' for ttk widgets)
                  # print(f"TclError configuring {widget.winfo_class()}: {e}")
                  pass


        # Recursively update children
        for child in widget.winfo_children():
            self.update_widget_colors(child, colors) # Pass the selected theme object 

    def my_parallel_processes(self):
        # ... (load data and update graph/report pages) ...
        # This should ideally run in a separate thread or process
        # to avoid blocking the GUI, especially if data loading is slow.
        # For simplicity now, it runs synchronously.
        print("Starting data processing...")
        self.set_status("Loading dashboard data...")
        try:
             accounts_df = get_all_list() # Fetch fresh data
             self.homeframe.all_graphs_function(accounts_df)
             self.reportframe.parallel_process_combo(accounts_df) # Update reports page combo/data
             self.is_graph_ready = 1
             self.set_status("Dashboard data loaded.")
             print("Data processing finished.")
        except Exception as e:
             self.set_status(f"[Error] Loading dashboard data: {e}")
             print(f"Error in my_parallel_processes: {e}")
    
    # def start_processing(self):
    #     with ThreadPoolExecutor() as executor:
    #         executor.submit(self.my_parallel_processes)


if __name__ == "__main__":
    # accounts_df = get_all_list()
    app = MyApp()
    # app.start_processing()
    # data_process = multiprocessing.Process(target=app.my_parallel_processes, args=(1,))
    # data_process.start()
    # print(time.time()-st)
    app.mainloop()
    # page 52 clouse 6.3
    # app.my_parallel_processes(1)

 
import pandas as pd
from database import accounts
# import accounts
import datetime
from datetime import date
# import time

def get_all_list():
    try:
        result = accounts.get_table("customers")
        column_names = ['customer_id', 'name', 'detail']
        customer_df = pd.DataFrame(result, columns=column_names)
    except Exception as e:
        print(f'Error in get_all_list: {str(e)}')
        return pd.DataFrame()
    
    try:
        customer_df[['Amount', 'Days']] = customer_df['customer_id'].apply(get_one_total).apply(pd.Series)
    except Exception as e:
        print(e)

    return customer_df

def get_one_total(customer_id):
    """
    Calculates the total amount and minimum days for a given customer, 
    taking into account compound interest and settlement dates.
    """
    try:
        transactions = accounts.get_normal_customer_transactions(customer_id)
        if not transactions:
            return pd.Series([0, 0])

        df = pd.DataFrame(transactions, columns=['id', 'date', 'description', 'amount', 'type', 'tags'])
        
        df['date'] = pd.to_datetime(df['date'])
        today_datetime = pd.to_datetime(date.today())
        df['days'] = (today_datetime - df['date']).dt.days
        min_days = df['days'].min() if not df.empty else 0
        total_balance = accounts.get_account_balance(customer_id)

        return pd.Series([round(total_balance, 2), min_days])

    except Exception as e:
        print(f'Error in get_one_total for customer {customer_id}: {str(e)}')
        return pd.Series([0, 0])



if __name__ == "__main__":
    print("hello")
    x = get_one_total(2)
    # x = get_all_list()
    print(x)
 
import pandas as pd
from database import accounts
# import accounts
import datetime
# import time

def get_all_list():
    try:
        result = accounts.get_table("customers")
        column_names = ['customer_id', 'name', 'detail']
        customer_df = pd.DataFrame(result, columns=column_names)
    except Exception as e:
        print(f'Error in get_all_list: {str(e)}')
        return pd.DataFrame()
    
    try:

        customer_df[['Amount', 'Days']] = customer_df['customer_id'].apply(get_one_total).apply(pd.Series)
    except Exception as e:
        print(e)

    return customer_df


def get_one_total(customer_id):
    try:
        result = accounts.get_table1(f"customer_{customer_id}")
    except Exception as e:
        print(f'Error in get_one_total: {str(e)}')
        return pd.Series([0, 0])
    try:
        table_df = pd.DataFrame(result)
        table_df[0] = pd.to_datetime(table_df[0])
        today = pd.to_datetime(datetime.date.today())

        table_df[3] = (today - table_df[0]).dt.days
        interest_one_day = 0.0006575342465753425
        table_df[4] = table_df[3] * interest_one_day
        table_df['result'] = table_df[1]
        table_df[2] = table_df[2].str.lower()
        table_df.loc[table_df[2] == "p", 'result'] *= table_df[4]
        table_df.loc[table_df[2] == "m", 'result'] *= -table_df[4]

        s1 = table_df['result'].sum()
        s = table_df.loc[table_df[2] == "p", 1].sum() - table_df.loc[table_df[2] == "m", 1].sum()

        last_days = table_df[3].min()
        mysum = round(s + s1, 2)

    except:
        return pd.Series([0, 0])

    return pd.Series([mysum, last_days])




 

 
import sqlite3
import datetime

'''
TAGS

0 = nill 
1 = normal
2 = no intrest
'''
# Create a connection to the accounts database
accounts_conn = sqlite3.connect('C://JBB//data//accounts.db')
accounts_cursor = accounts_conn.cursor()


# Create a table to store information about all customers
accounts_cursor.execute('''CREATE TABLE IF NOT EXISTS customers
                (id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT,
                other_details TEXT)''')

# Function to add a new customer to the database
def add_new_customer(name, other_details):
    accounts_cursor.execute("""
        INSERT INTO customers (name, other_details)
        VALUES (?, ?)
    """, (name, other_details))
    id = accounts_cursor.lastrowid
    # Create a new table for the customer with their ID
    accounts_cursor.execute(f'''CREATE TABLE IF NOT EXISTS customer_{id}
                       (id INTEGER PRIMARY KEY AUTOINCREMENT,
                       date TEXT,
                       description TEXT,
                       amount REAL,
                       type TEXT,
                       tags TEXT)''')
    # Insert the new customer into the main customers table
    accounts_conn.commit()

    return id


# Function to get a list of all customer IDs
def get_customer_ids():
    accounts_cursor.execute("SELECT id FROM customers")
    return [row[0] for row in accounts_cursor.fetchall()]

# Function to get customer details by ID
def get_customer_details(customer_id):
    accounts_cursor.execute(f"SELECT * FROM customers WHERE id = {customer_id}")
    return accounts_cursor.fetchone()

def get_all_customers():
    accounts_cursor.execute(f"select * from customers")
    return accounts_cursor.fetchall()

def get_all_customers_name_and_id():
    accounts_cursor.execute(f"select id, name from customers")
    return accounts_cursor.fetchall()

# Function to get all transactions for a specific customer
def get_customer_transactions(customer_id):
    table_name = f'customer_{customer_id}'
    accounts_cursor.execute(f"SELECT * FROM {table_name}")
    return accounts_cursor.fetchall()

def get_normal_customer_transactions(customer_id):
    table_name = f'customer_{customer_id}'
    accounts_cursor.execute(f"SELECT * FROM {table_name} where tags != '0'")
    return accounts_cursor.fetchall()

def get_transaction_by_id(table_name, transaction_id):
    # table_name = "customer_" + str(item_id)
    accounts_cursor.execute(f"SELECT * FROM {table_name} WHERE id = ?", (transaction_id,))
    transaction = accounts_cursor.fetchone()
    return transaction

# Function to add a new transaction for a specific customer
def add_customer_transaction(customer_id, date, description, amount, transaction_type, tags=''):
    table_name = f'customer_{customer_id}'
    accounts_cursor.execute(f'''INSERT INTO {table_name}
                                 (date, description, amount, type, tags)
                                 VALUES (?, ?, ?, ?, ?)''',
                            (date, description, amount, transaction_type, tags))
    accounts_conn.commit()



def update_customer_details(customer_id, name=None, other_details=None):
    query = "UPDATE customers SET "
    updates = []
    if name:
        updates.append("name = '{}'".format(name))
    if other_details:
        updates.append("other_details = '{}'".format(other_details))
    if not updates:
        return False
    query += ", ".join(updates)
    query += " WHERE id = {}".format(customer_id)
    accounts_cursor.execute(query)
    accounts_conn.commit()
    return True

def delete_customer(customer_id):
    query = "DROP TABLE IF EXISTS customer_{}".format(customer_id)
    accounts_cursor.execute(query)
    query = "DELETE FROM customers WHERE id = {}".format(customer_id)
    accounts_cursor.execute(query)
    accounts_conn.commit()
    return True


def update_customer_transaction(table_name, transaction_id, date, description, amount, transaction_type, tags):
    """
    Update an existing transaction for a customer in the accounts database.
    """
    query = "UPDATE {} SET date=?, description=?, amount=?, type=?, tags=? WHERE id=?".format(table_name)
    values = (date, description, amount, transaction_type, tags, transaction_id)
    accounts_cursor.execute(query, values)
    accounts_conn.commit()

def delete_customer_transaction(customer_id, transaction_id):
    """
    Delete a transaction for a customer from the accounts database.
    """
    query = "DELETE FROM customer_{} WHERE id=?".format(customer_id)
    values = (transaction_id,)
    accounts_cursor.execute(query, values)
    accounts_conn.commit()
    

def get_table(table_name):
    accounts_cursor.execute(f"select * from {table_name}")
    return accounts_cursor.fetchall()

def get_table1(table_name):
    accounts_cursor.execute(f"select date, amount, type, tags from {table_name} where tags != '0'")
    return accounts_cursor.fetchall()


def calculate_interest(principle_amount, from_date_str, to_date=datetime.date.today()):
        """
        Calculates interest earned on a principle amount, considering financial year-end (March 31st).

        Args:
            principle_amount (float): The initial amount of money.
            from_date_str (str): The starting date for interest calculation in "YYYY-MM-DD" format.
            to_date (datetime.date, optional): The ending date for interest calculation. Defaults to today.

        Returns:
            float: The calculated interest amount.
        """
        daily_interest_rate = 0.0006575342465753425 
        from_date = datetime.datetime.strptime(from_date_str, "%Y-%m-%d").date()
        total_interest = 0

        while from_date < to_date:
            year_end = datetime.date(from_date.year, 3, 31) 
            if from_date.month > 3:
                year_end = datetime.date(from_date.year + 1, 3, 31)
            end_date = min(year_end, to_date)
            days = (end_date - from_date).days
            interest = principle_amount * days * daily_interest_rate
            total_interest += interest
            principle_amount += interest 
            from_date = end_date + datetime.timedelta(days=1)

        return round(total_interest, 2)

def find_last_settlement_date(customer_id):
    """Finds the date of the last settled transaction."""
    table_name = f"customer_{customer_id}"
    accounts_cursor.execute(f"SELECT MAX(date) FROM {table_name} WHERE tags = '0'")
    result = accounts_cursor.fetchone()
    return result[0] if result[0] is not None else None

def find_last_settlement_id_on_date(customer_id, last_settlement_date):
    """Finds the id of the last settled transaction on a given date."""
    table_name = f"customer_{customer_id}"
    accounts_cursor.execute(f"""
        SELECT id FROM {table_name}
        WHERE date = ? AND tags = '0'
        ORDER BY id DESC
    """, (last_settlement_date,))
    result = accounts_cursor.fetchone()
    return result[0] if result is not None else None

def get_account_balance(customer_id):
    """Calculates the account balance for a customer, including interest,
       considering only the current (unsettled) period.
    """
    table_name = f"customer_{customer_id}"
    last_settlement_date = find_last_settlement_date(customer_id)
    
    if last_settlement_date is not None:
        last_settlement_id_on_date = find_last_settlement_id_on_date(customer_id, last_settlement_date)

        accounts_cursor.execute(f"""
            SELECT * FROM {table_name}
            WHERE (date > ?) OR (date = ? AND id > ?) 
            ORDER BY date, id
        """, (last_settlement_date, last_settlement_date, last_settlement_id_on_date))

    else:
        # No settlements, include all transactions 
        accounts_cursor.execute(f"SELECT * FROM {table_name} ORDER BY date, id")

    transactions = accounts_cursor.fetchall()
    balance = 0.0

    for row in transactions:
        date_str = row[1]
        amount = row[3]
        transaction_type = row[4]
        tag = row[5]

        if tag == '1':  # Interest-bearing transaction
            interest = calculate_interest(amount, date_str)
            total = amount + interest
        else:  # No-interest transaction (tag=2) 
            total = amount

        if transaction_type == "P":
            balance += total
        else: # if transaciton type = "M"
            balance -= total

    return round(balance, 2)

# print(get_account_balace(1))


if __name__ =='__main__':
    while True:
        
        x = input(": ")
        if x == "q":
            break
        accounts_cursor.execute(x)
        for i in accounts_cursor.fetchall():
            print(i)
        accounts_conn.commit()
    
    # print(get_account_balance(2))
    # x = get_all_customers_name_and_id()
    # x = [f"{i[0]} {i[1]}" for i in x]
    # for i in x:
    #     print(i)
 
# database/crop_database.py
import sqlite3
import os
from datetime import datetime

DB_FOLDER = "C://JBB//data"
DB_NAME = os.path.join(DB_FOLDER, "crop_trading.db")

# Ensure the data folder exists
os.makedirs(DB_FOLDER, exist_ok=True)

def get_db_connection():
    """Establishes and returns a database connection."""
    conn = None
    try:
        conn = sqlite3.connect(DB_NAME)
        conn.row_factory = sqlite3.Row # Return rows as dictionary-like objects
        # Enable foreign key support
        conn.execute("PRAGMA foreign_keys = ON")
    except sqlite3.Error as e:
        print(f"Error connecting to database: {e}")
    return conn

def initialize_database():
    """Creates the necessary tables if they don't exist."""
    conn = get_db_connection()
    if not conn:
        return
    cursor = conn.cursor()
    try:
        # Farmers Table (Similar to customers)
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS farmers (
                farmer_id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL UNIQUE,
                details TEXT
            )
        ''')

        # Crops Table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS crops (
                crop_id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL UNIQUE,
                unit TEXT DEFAULT 'KG'
            )
        ''')

        # Purchases Table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS purchases (
                purchase_id INTEGER PRIMARY KEY AUTOINCREMENT,
                farmer_id INTEGER NOT NULL,
                crop_id INTEGER NOT NULL,
                date TEXT NOT NULL,
                net_quantity REAL NOT NULL,
                k_quantity REAL DEFAULT 0,
                actual_quantity REAL NOT NULL, -- Calculated: net_quantity - k_quantity
                purchase_rate REAL NOT NULL,
                total_amount REAL NOT NULL,    -- Calculated: actual_quantity * purchase_rate
                FOREIGN KEY (farmer_id) REFERENCES farmers(farmer_id) ON DELETE RESTRICT,
                FOREIGN KEY (crop_id) REFERENCES crops(crop_id) ON DELETE RESTRICT
            )
        ''')

        # Sales Table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS sales (
                sale_id INTEGER PRIMARY KEY AUTOINCREMENT,
                crop_id INTEGER NOT NULL,
                date TEXT NOT NULL,
                sale_quantity REAL NOT NULL,
                sale_rate REAL NOT NULL,
                total_amount REAL NOT NULL, -- Calculated: sale_quantity * sale_rate
                buyer_details TEXT,        -- Optional: Name or 'Cash Sale' etc.
                FOREIGN KEY (crop_id) REFERENCES crops(crop_id) ON DELETE RESTRICT
            )
        ''')

        # Stock Table (To maintain current levels and average cost)
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS stock (
                crop_id INTEGER PRIMARY KEY,
                current_quantity REAL DEFAULT 0,
                average_cost REAL DEFAULT 0, -- Weighted average cost
                FOREIGN KEY (crop_id) REFERENCES crops(crop_id) ON DELETE CASCADE
            )
        ''')

        conn.commit()
        print("Crop trading database initialized successfully.")
    except sqlite3.Error as e:
        print(f"Error initializing crop trading database: {e}")
    finally:
        if conn:
            conn.close()

# --- Farmer Functions ---
def add_farmer(name, details=""):
    sql = 'INSERT INTO farmers (name, details) VALUES (?, ?)'
    conn = get_db_connection()
    if not conn: return None
    cursor = conn.cursor()
    try:
        cursor.execute(sql, (name.upper(), details.upper()))
        conn.commit()
        return cursor.lastrowid
    except sqlite3.IntegrityError:
         print(f"Farmer '{name}' already exists.")
         return None # Indicate failure due to unique constraint
    except sqlite3.Error as e:
        print(f"Error adding farmer: {e}")
        return None
    finally:
        if conn: conn.close()

def get_farmers():
    sql = 'SELECT farmer_id, name, details FROM farmers ORDER BY name'
    conn = get_db_connection()
    if not conn: return []
    cursor = conn.cursor()
    try:
        cursor.execute(sql)
        farmers = cursor.fetchall()
        # Convert Row objects to simple lists or tuples if needed by GUI
        return [list(f) for f in farmers]
    except sqlite3.Error as e:
        print(f"Error getting farmers: {e}")
        return []
    finally:
        if conn: conn.close()

# --- Crop Functions ---
def add_crop(name, unit="KG"):
    sql = 'INSERT INTO crops (name, unit) VALUES (?, ?)'
    conn = get_db_connection()
    if not conn: return None
    cursor = conn.cursor()
    try:
        cursor.execute(sql, (name.upper(), unit.upper()))
        conn.commit()
        crop_id = cursor.lastrowid
        # Initialize stock entry for the new crop
        cursor.execute('INSERT OR IGNORE INTO stock (crop_id) VALUES (?)', (crop_id,))
        conn.commit()
        return crop_id
    except sqlite3.IntegrityError:
         print(f"Crop '{name}' already exists.")
         return None
    except sqlite3.Error as e:
        print(f"Error adding crop: {e}")
        return None
    finally:
        if conn: conn.close()

def get_crops():
    sql = 'SELECT crop_id, name, unit FROM crops ORDER BY name'
    conn = get_db_connection()
    if not conn: return []
    cursor = conn.cursor()
    try:
        cursor.execute(sql)
        crops = cursor.fetchall()
        return [list(c) for c in crops]
    except sqlite3.Error as e:
        print(f"Error getting crops: {e}")
        return []
    finally:
        if conn: conn.close()

# --- Stock Update (Helper Function) ---
def _update_stock_on_purchase(cursor, crop_id, purchased_actual_quantity, purchase_rate):
    """Updates stock quantity and average cost upon purchase."""
    cursor.execute('SELECT current_quantity, average_cost FROM stock WHERE crop_id = ?', (crop_id,))
    stock_data = cursor.fetchone()

    if stock_data:
        old_quantity = stock_data['current_quantity']
        old_avg_cost = stock_data['average_cost']

        new_quantity = old_quantity + purchased_actual_quantity

        if new_quantity <= 0 or purchased_actual_quantity <= 0 : # Avoid division by zero or illogical updates
             new_avg_cost = old_avg_cost # Keep old cost if purchase qty is zero
        elif old_quantity <= 0 :
             new_avg_cost = purchase_rate # If starting from zero stock, cost is just the purchase rate
        else:
             # Calculate weighted average cost
             new_avg_cost = ((old_avg_cost * old_quantity) + (purchase_rate * purchased_actual_quantity)) / new_quantity

        cursor.execute('''
            UPDATE stock
            SET current_quantity = ?, average_cost = ?
            WHERE crop_id = ?
        ''', (new_quantity, new_avg_cost, crop_id))
    else:
        # Should not happen if add_crop initializes stock, but handle defensively
        new_quantity = purchased_actual_quantity
        new_avg_cost = purchase_rate
        cursor.execute('''
             INSERT INTO stock (crop_id, current_quantity, average_cost)
             VALUES (?, ?, ?)
        ''', (crop_id, new_quantity, new_avg_cost))


def _update_stock_on_sale(cursor, crop_id, sold_quantity):
    """Updates stock quantity upon sale. Does NOT change average cost."""
    cursor.execute('SELECT current_quantity FROM stock WHERE crop_id = ?', (crop_id,))
    stock_data = cursor.fetchone()

    if stock_data:
        old_quantity = stock_data['current_quantity']
        new_quantity = old_quantity - sold_quantity
        # Optional: Add check here to prevent selling more than available
        # if new_quantity < 0:
        #    raise ValueError("Insufficient stock for this sale.")

        cursor.execute('''
            UPDATE stock SET current_quantity = ? WHERE crop_id = ?
        ''', (new_quantity, crop_id))
    else:
         # This indicates an issue - trying to sell a crop not in stock table
         print(f"Warning: Trying to sell crop_id {crop_id} which has no stock record.")


# --- Purchase Functions ---
def record_purchase(farmer_id, crop_id, date_str, net_quantity, k_quantity, purchase_rate):
    if not all([farmer_id, crop_id, date_str, net_quantity is not None, k_quantity is not None, purchase_rate is not None]):
         print("Error: Missing data for purchase.")
         return None, "Missing data"

    try:
        net_q = float(net_quantity)
        k_q = float(k_quantity)
        rate = float(purchase_rate)

        if net_q < 0 or k_q < 0 or rate < 0:
             raise ValueError("Quantities and rate cannot be negative.")
        if k_q > net_q:
             raise ValueError("K-Quantity cannot be greater than Net Quantity.")

        actual_quantity = net_q - k_q
        total_amount = actual_quantity * rate

    except ValueError as e:
        print(f"Invalid input for purchase: {e}")
        return None, str(e)

    sql = '''
        INSERT INTO purchases
        (farmer_id, crop_id, date, net_quantity, k_quantity, actual_quantity, purchase_rate, total_amount)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    '''
    conn = get_db_connection()
    if not conn: return None, "Database connection failed"
    cursor = conn.cursor()
    try:
        cursor.execute(sql, (farmer_id, crop_id, date_str, net_q, k_q, actual_quantity, rate, total_amount))
        purchase_id = cursor.lastrowid
        # Update stock
        _update_stock_on_purchase(cursor, crop_id, actual_quantity, rate)
        conn.commit()
        return purchase_id, "Success"
    except sqlite3.Error as e:
        conn.rollback() # Rollback on error
        print(f"Error recording purchase: {e}")
        return None, str(e)
    finally:
        if conn: conn.close()


# --- Sale Functions ---
def record_sale(crop_id, date_str, sale_quantity, sale_rate, buyer_details=""):
    if not all([crop_id, date_str, sale_quantity is not None, sale_rate is not None]):
         print("Error: Missing data for sale.")
         return None, "Missing data"

    try:
        sale_q = float(sale_quantity)
        rate = float(sale_rate)

        if sale_q <= 0 or rate <= 0:
            raise ValueError("Sale quantity and rate must be positive.")

        total_amount = sale_q * rate

    except ValueError as e:
        print(f"Invalid input for sale: {e}")
        return None, str(e)

    sql = '''
        INSERT INTO sales
        (crop_id, date, sale_quantity, sale_rate, total_amount, buyer_details)
        VALUES (?, ?, ?, ?, ?, ?)
    '''
    conn = get_db_connection()
    if not conn: return None, "Database connection failed"
    cursor = conn.cursor()
    try:
        # Optional: Check stock before recording sale
        # cursor.execute('SELECT current_quantity FROM stock WHERE crop_id = ?', (crop_id,))
        # current_stock = cursor.fetchone()
        # if not current_stock or current_stock['current_quantity'] < sale_q:
        #     return None, f"Insufficient stock for crop ID {crop_id}. Available: {current_stock['current_quantity'] if current_stock else 0}"

        cursor.execute(sql, (crop_id, date_str, sale_q, rate, total_amount, buyer_details.upper()))
        sale_id = cursor.lastrowid
        # Update stock
        _update_stock_on_sale(cursor, crop_id, sale_q)
        conn.commit()
        return sale_id, "Success"
    except sqlite3.Error as e:
        conn.rollback()
        print(f"Error recording sale: {e}")
        return None, str(e)
    finally:
        if conn: conn.close()

# --- Reporting Functions ---
def get_stock_summary():
    """Gets current stock levels and average costs."""
    sql = '''
        SELECT c.name, c.unit, s.current_quantity, s.average_cost,
               (s.current_quantity * s.average_cost) AS total_value
        FROM stock s
        JOIN crops c ON s.crop_id = c.crop_id
        ORDER BY c.name
    '''
    conn = get_db_connection()
    if not conn: return []
    cursor = conn.cursor()
    try:
        cursor.execute(sql)
        summary = cursor.fetchall()
        return [list(s) for s in summary] # Return as list of lists
    except sqlite3.Error as e:
        print(f"Error getting stock summary: {e}")
        return []
    finally:
        if conn: conn.close()

def get_purchase_history(farmer_id=None, crop_id=None, start_date=None, end_date=None):
    """Gets purchase history, optionally filtered."""
    base_sql = '''
        SELECT p.purchase_id, p.date, f.name as farmer_name, c.name as crop_name,
               p.net_quantity, p.k_quantity, p.actual_quantity, p.purchase_rate, p.total_amount
        FROM purchases p
        JOIN farmers f ON p.farmer_id = f.farmer_id
        JOIN crops c ON p.crop_id = c.crop_id
    '''
    filters = []
    params = []

    if farmer_id:
        filters.append("p.farmer_id = ?")
        params.append(farmer_id)
    if crop_id:
        filters.append("p.crop_id = ?")
        params.append(crop_id)
    if start_date:
        filters.append("p.date >= ?")
        params.append(start_date)
    if end_date:
        filters.append("p.date <= ?")
        params.append(end_date)

    if filters:
        base_sql += " WHERE " + " AND ".join(filters)

    base_sql += " ORDER BY p.date DESC, p.purchase_id DESC"

    conn = get_db_connection()
    if not conn: return []
    cursor = conn.cursor()
    try:
        cursor.execute(base_sql, params)
        history = cursor.fetchall()
        return [list(h) for h in history]
    except sqlite3.Error as e:
        print(f"Error getting purchase history: {e}")
        return []
    finally:
        if conn: conn.close()


def get_sales_history(crop_id=None, start_date=None, end_date=None):
    """Gets sales history, optionally filtered."""
    base_sql = '''
        SELECT s.sale_id, s.date, c.name as crop_name, s.sale_quantity, s.sale_rate,
               s.total_amount, s.buyer_details
        FROM sales s
        JOIN crops c ON s.crop_id = c.crop_id
    '''
    filters = []
    params = []

    if crop_id:
        filters.append("s.crop_id = ?")
        params.append(crop_id)
    if start_date:
        filters.append("s.date >= ?")
        params.append(start_date)
    if end_date:
        filters.append("s.date <= ?")
        params.append(end_date)

    if filters:
        base_sql += " WHERE " + " AND ".join(filters)

    base_sql += " ORDER BY s.date DESC, s.sale_id DESC"

    conn = get_db_connection()
    if not conn: return []
    cursor = conn.cursor()
    try:
        cursor.execute(base_sql, params)
        history = cursor.fetchall()
        return [list(h) for h in history]
    except sqlite3.Error as e:
        print(f"Error getting sales history: {e}")
        return []
    finally:
        if conn: conn.close()

# --- General DB Utility ---
def get_table_data(table_name):
    """Generic function to get all data from a table."""
    conn = get_db_connection()
    if not conn: return [], []
    cursor = conn.cursor()
    try:
        cursor.execute(f"PRAGMA table_info({table_name})")
        columns = [col[1] for col in cursor.fetchall()] # Get column names
        cursor.execute(f"SELECT * FROM {table_name}")
        data = cursor.fetchall()
        return columns, [list(row) for row in data]
    except sqlite3.Error as e:
        print(f"Error getting data for table {table_name}: {e}")
        return [], []
    finally:
        if conn: conn.close()

def get_table_names():
     """Gets all table names from the database."""
     conn = get_db_connection()
     if not conn: return []
     cursor = conn.cursor()
     try:
         cursor.execute("SELECT name FROM sqlite_master WHERE type='table' ORDER BY name")
         tables = cursor.fetchall()
         return [t['name'] for t in tables]
     except sqlite3.Error as e:
        print(f"Error getting table names: {e}")
        return []
     finally:
        if conn: conn.close()


# --- Initialization ---
if __name__ == "__main__":
    print("Initializing Crop Trading Database...")
    initialize_database()
    print("Adding sample data (if needed)...")
    # Example: Add a farmer and crop if they don't exist
    # farmer_id = add_farmer("DEFAULT FARMER", "Initial Sample")
    # crop_id = add_crop("WHEAT", "KG")
    # if farmer_id and crop_id:
    #     print("Sample farmer and crop added/exist.")
    #     # You could add a sample purchase here for testing
    #     # record_purchase(farmer_id, crop_id, datetime.now().strftime('%Y-%m-%d'), 1000, 10, 20)

    print("Testing get functions:")
    print("Farmers:", get_farmers())
    print("Crops:", get_crops())
    print("Stock Summary:", get_stock_summary())
 
import sqlite3

from datetime import datetime, timedelta
from sqlite3 import Error

try:
    daily_conn = sqlite3.connect('C://JBB//data//daily_notes.db')
    daily_cursor = daily_conn.cursor()
    today = datetime.now().strftime('%Y_%m_%d')
    daily_cursor.execute(f"CREATE TABLE IF NOT EXISTS d{today} (id INTEGER PRIMARY KEY AUTOINCREMENT, description TEXT)")
    daily_conn.commit()

except Error as e:
    print(e, "error")

def table_exists(table_name):
    daily_cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name=?", (table_name,))
    result = daily_cursor.fetchone()
    return result is not None

def last_7_day_report():
    today = datetime.now().date()

    # Create a list of the last 7 dates
    last_7_dates = [today - timedelta(days=i) for i in range(6, -1, -1)]
    last_7_dates = [i.strftime('%Y_%m_%d') for i in last_7_dates]

    last7dayslist = []
    for i in last_7_dates:
        temp = [i.split("_")[2]]
        if table_exists(f"d{i}"):
            daily_cursor.execute(f"SELECT COUNT(*) FROM d{i}")
            x = daily_cursor.fetchone()[0]
            temp.append(x)
        
        else:
            temp.append(0)

        last7dayslist.append(temp)
        # print(temp)
        # for k in j:
        #     print(k)

    # Print the list of dates
    # print(last7dayslist)
    return last7dayslist


def add_today_table(daily_notes_conn, daily_notes_cursor):
    # Get today's date
    today = datetime.now().strftime('%Y_%m_%d')
    
    # Check if table already exists for today's date
    daily_notes_cursor.execute(f"SELECT name FROM sqlite_master WHERE type='table' AND name=f'd{today}'")
    if daily_notes_cursor.fetchone() is not None:
        print("Table already exists for today's date")
        return
    
    # Create table for today's date
    daily_notes_cursor.execute(f"CREATE TABLE IF NOT EXISTS d{today} (id INTEGER PRIMARY KEY AUTOINCREMENT, description TEXT)")
    daily_notes_conn.commit()
    
    print(f"Table d{today} created successfully")

    
def add_note_to_date(note, date=datetime.now().strftime('%Y_%m_%d') ):
    try:
        
        # Create table if not exists
        table_name = date
        daily_cursor.execute(f"CREATE TABLE IF NOT EXISTS d{table_name} (id INTEGER PRIMARY KEY, description TEXT)")
        
        # Insert new note
        daily_cursor.execute(f"INSERT INTO d{table_name} (description) VALUES (?)", (note,))
        id = daily_cursor.lastrowid
        daily_conn.commit()
        print("Note added successfully.", note)
        return id
        
    except Error as e:       
        print(e)
        return 0

def get_notes(date):
    table_name = date.replace("-", "_")
    daily_cursor.execute(f"SELECT * FROM d{table_name}")
    notes = daily_cursor.fetchall()
    
    return notes

def update_note(date, note_id, new_description):
    table_name = date.replace("-", "_")
    daily_cursor.execute(f"UPDATE d{table_name} SET description=? WHERE id=?", (new_description, note_id))
    daily_conn.commit()
    

def delete_note(date, note_id):
    table_name = date.replace("-", "_")
    daily_cursor.execute(f"DELETE FROM d{table_name} WHERE id=?", (note_id,))
    daily_conn.commit()


def get_table(table_name):
    daily_cursor.execute(f"select * from {table_name}")
    return daily_cursor.fetchall()

def get_todays_notes_summary():
    """Gets a count of notes added today."""
    today_str = datetime.now().strftime('%Y_%m_%d')
    table_name = f"d{today_str}"
    count = 0
    try:
        # Check if table exists first to avoid error
        daily_cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name=?", (table_name,))
        if daily_cursor.fetchone():
            daily_cursor.execute(f"SELECT COUNT(*) FROM {table_name}")
            result = daily_cursor.fetchone()
            if result:
                count = result[0]
    except sqlite3.Error as e:
        print(f"Error getting today's notes count ({table_name}): {e}")
    except Exception as e_gen:
         print(f"Unexpected error in get_todays_notes_summary: {e_gen}")
    return count



if __name__ == '__main__':
    print('main')
    last_7_day_report()
 
import sqlite3

# connect to the inventory database
inventory_conn = sqlite3.connect('C://JBB//data//inventory.db')
inventory_cursor = inventory_conn.cursor()

# add auto-increment to the id column in the items table
inventory_cursor.execute("""
    CREATE TABLE IF NOT EXISTS items (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT,
        stock_value INTEGER DEFAULT 0,
        last_value INTEGER DEFAULT 0,
        unit TEXT DEFAULT 'PCS',
        batch TEXT DEFAULT 'NA', 
        expiry_date TEXT DEFAULT 'NA', 
        gst_rate INTEGER DEFAULT 0,
        item_type TEXT default 'S',
        pakka_kacha INTEGER DEFAULT 1
    )
""")

alter_queries = [
    "ALTER TABLE items ADD COLUMN unit TEXT DEFAULT 'PCS';",
    "ALTER TABLE items ADD COLUMN batch TEXT DEFAULT 'NA';",
    "ALTER TABLE items ADD COLUMN expiry_date TEXT DEFAULT 'NA';",
    "ALTER TABLE items ADD COLUMN gst_rate INTEGER DEFAULT 0;",
    "ALTER TABLE items ADD COLUMN item_type TEXT DEFAULT 'S';",
    "ALTER TABLE items ADD COLUMN pakka_kacha INTEGER DEFAULT 1;"
]
# for query in alter_queries:
#     inventory_cursor.execute(query)

# inventory_cursor.execute("""CREATE TABLE new_table (id INTEGER PRIMARY KEY AUTOINCREMENT,
#         name TEXT,
#         stock_value INTEGER DEFAULT 0,
#         last_value INTEGER DEFAULT 0 )
#                          """)
# inventory_cursor.execute("insert into new_table (id, name, stock_value, last_value) select id, name, stock_value, last_value from items")
# inventory_cursor.execute("DROP TABLE items")
# inventory_cursor.execute("ALTER TABLE new_table RENAME TO items")

# inventory_cursor.execute("drop table new_table")
# inventory_conn.commit()
# inventory_cursor.execute(" PRAGMA table_info(items);")
# print(inventory_cursor.fetchall())


# function to add a new item and create a table for it
def add_new_item(name, stock_value, last_value, unit, batch, expiry_date, gst_rate, item_type, pakka_kacha):
    # insert the new item into the items table and get its auto-incremented id
    inventory_cursor.execute("""
        INSERT INTO items (name, stock_value, last_value, unit, batch, expiry_date, gst_rate, item_type, pakka_kacha)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    """, (name, stock_value, last_value, unit, batch, expiry_date, gst_rate, item_type, pakka_kacha))
    item_id = inventory_cursor.lastrowid
    
    # create a new table for the item with its id as the table name
    inventory_cursor.execute(f"""
        CREATE TABLE IF NOT EXISTS item_{item_id} (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            date TEXT,
            received INTEGER,
            sale INTEGER,
            description TEXT,
            tags TEXT
        )
    """)
    
    # commit the changes to the database
    inventory_conn.commit()
    
    # return the id of the new item
    return item_id

def add_item_transaction(item_id, date, recieved, sale, description, tags=''):
    table_name = f'item_{item_id}'
    inventory_cursor.execute(f'''INSERT INTO {table_name}
                                 (date, received, sale, description, tags)
                                 VALUES (?, ?, ?, ?, ?)''',
                            (date, recieved, sale, description, tags))
    inventory_conn.commit()


# Function to modify an item
def modify_item(item_id, name, stock_value, last_value, unit, batch, expiry_date, gst_rate, item_type, pakka_kacha):
    inventory_cursor.execute("UPDATE items SET name=?, stock_value=?, last_value=?, unit=?, batch=?, expiry_date=?, gst_rate=?, item_type=?, pakka_kacha=? WHERE id=?", (name, stock_value, last_value, unit, batch, expiry_date, gst_rate, item_type, pakka_kacha, item_id))
    inventory_conn.commit()
    print("Item with id", item_id, "has been modified.")

# Function to delete an item
def delete_item(item_id):
    # First, drop the corresponding item table
    inventory_cursor.execute("DROP TABLE IF EXISTS item_{}".format(item_id))
    # Then, delete the item from the main items table
    inventory_cursor.execute("DELETE FROM items WHERE id=?", (item_id,))
    inventory_conn.commit()
    print("Item with id", item_id, "has been deleted.")



# Define function to get all items
def get_all_items():
    inventory_cursor.execute('SELECT * FROM items')
    items = inventory_cursor.fetchall()
    return items

def get_all_items_id_and_name():
    inventory_cursor.execute('SELECT id, name FROM items')
    items = inventory_cursor.fetchall()
    return items

# Define function to get item by id
def get_item_by_id(item_id):
    inventory_cursor.execute('SELECT * FROM items WHERE id=?', (item_id,))
    item = inventory_cursor.fetchone()
    return item

# Define function to get all transactions for an item
def get_item_transactions(item_id):
    table_name = 'item_' + str(item_id)
    inventory_cursor.execute(f'SELECT * FROM {table_name}')
    transactions = inventory_cursor.fetchall()
    return transactions

def get_transaction_by_id(table_name, transaction_id):
    # table_name = "item_" + str(item_id)
    inventory_cursor.execute(f"SELECT * FROM {table_name} WHERE id = ?", (transaction_id,))
    transaction = inventory_cursor.fetchone()
    return transaction


# function to modify transaction for an item
def modify_transaction(item_id, transaction_id, date, received, sale, description, tags):
    # check if the item exists in the inventory database
    inventory_cursor.execute('SELECT name FROM items WHERE id=?', (item_id,))
    item_name = inventory_cursor.fetchone()
    if item_name is None:
        print(f'Error: Item with ID {item_id} does not exist in the inventory database')
        return

    # check if the transaction exists in the item's transaction table
    item_table_name = f'item_{item_id}'
    inventory_cursor.execute(f'SELECT id FROM {item_table_name} WHERE id=?', (transaction_id,))
    transaction = inventory_cursor.fetchone()
    if transaction is None:
        print(f'Error: Transaction with ID {transaction_id} does not exist for item {item_name[0]}')
        return

    # update the transaction in the item's transaction table
    inventory_cursor.execute(f'UPDATE {item_table_name} SET date=?, received=?, sale=?, description=?, tags=? WHERE id=?',
                              (date, received, sale, description, tags, transaction_id))
    inventory_conn.commit()
    print(f'Transaction {transaction_id} for item {item_name[0]} has been modified successfully')


# function to delete a transaction for an item
def delete_transaction(item_id, transaction_id):
    # check if the item exists in the inventory database
    inventory_cursor.execute('SELECT name FROM items WHERE id=?', (item_id,))
    item_name = inventory_cursor.fetchone()
    if item_name is None:
        print(f'Error: Item with ID {item_id} does not exist in the inventory database')
        return

    # check if the transaction exists in the item's transaction table
    item_table_name = f'item_{item_id}'
    inventory_cursor.execute(f'SELECT id FROM {item_table_name} WHERE id=?', (transaction_id,))
    transaction = inventory_cursor.fetchone()
    if transaction is None:
        print(f'Error: Transaction with ID {transaction_id} does not exist for item {item_name[0]}')
        return

    # delete the transaction from the item's transaction table
    inventory_cursor.execute(f'DELETE FROM {item_table_name} WHERE id=?', (transaction_id,))
    inventory_conn.commit()
    print(f'Transaction {transaction_id} for item {item_name[0]} has been deleted successfully')

def get_item_transactions(item_id):
    transactions = []
    try:
        inventory_cursor.execute(f"SELECT * FROM item_{item_id}")
        rows = inventory_cursor.fetchall()
        for row in rows:
            transaction = {
                "id": row[0],
                "date": row[1],
                "received": row[2],
                "sale": row[3],
                "description": row[4],
                "tags": row[5]
            }
            transactions.append(transaction)
    except sqlite3.Error as e:
        print(f"Error getting transactions for item {item_id}: {e}")
    return transactions

def get_item_quantity(item_id):
    quantity = 0
    try:
        inventory_cursor.execute(f"SELECT SUM(received - sale) FROM item_{item_id}")
        row = inventory_cursor.fetchone()
        if row[0]:
            quantity = row[0]
    except sqlite3.Error as e:
        print(f"Error getting quantity for item {item_id}: {e}")
    return quantity

def get_item_value(item_id):
    quantity = get_item_quantity(item_id)
    inventory_cursor.execute(f"SELECT stock_value FROM items where id={item_id}")
    row = inventory_cursor.fetchone()[0]
    value = quantity * row
    return value

def get_inventory_value():
    value = 0
    try:
        inventory_cursor.execute("SELECT id, stock_value FROM items")
        rows = inventory_cursor.fetchall()
        for row in rows:
            item_value = get_item_value(row[0], row[1])
            value += item_value
    except sqlite3.Error as e:
        print(f"Error getting inventory value: {e}")
    return value

def get_last_value(item_id):
    inventory_cursor.execute(f"SELECT last_value FROM items where id={item_id}")
    row = inventory_cursor.fetchone()[0]
    return row

def set_last_value(item_id, value):
    inventory_cursor.execute("UPDATE items SET last_value=? WHERE id=?", (value, item_id))
    inventory_conn.commit()
    return f'Item Id {item_id} updated to value {value}'

def get_table(table_name):
    inventory_cursor.execute(f"select * from {table_name}")
    return inventory_cursor.fetchall()

if __name__ == '__main__':
    print('hello')
    print(get_last_value(4))
    # inventory_cursor.execute(f'DELETE FROM items WHERE name=?', ("TEST 2",))
    # inventory_conn.commit()
    # print(get_item_value(44))
    # get_item_value(44)

def get_total_inventory_value():
    """Calculates the total value of all items currently in stock."""
    total_value = 0.0
    try:
        items = get_all_items() # Get list of all items [id, name, stock_val, last_val, ...]
        for item in items:
            item_id = item[0]
            stock_value_per_unit = float(item[2]) if item[2] else 0.0 # Use 'stock_value'
            quantity = get_item_quantity(item_id) # Assumes this function exists and is correct
            total_value += quantity * stock_value_per_unit
    except Exception as e:
        print(f"Error calculating total inventory value: {e}")
    return round(total_value, 2)

def get_low_stock_items(threshold=5):
    """Retrieves items with stock quantity at or below a threshold."""
    low_stock = []
    try:
        items = get_all_items_id_and_name() # Get [(id, name), ...]
        for item_id, name in items:
            quantity = get_item_quantity(item_id)
            if quantity <= threshold:
                low_stock.append((item_id, name, quantity))
        # Sort by quantity (lowest first)
        low_stock.sort(key=lambda x: x[2])
    except Exception as e:
        print(f"Error getting low stock items: {e}")
    return low_stock

# Ensure get_item_quantity is robust
def get_item_quantity(item_id):
    quantity = 0
    try:
        inventory_cursor.execute(f"SELECT SUM(received - sale) FROM item_{item_id}")
        row = inventory_cursor.fetchone()
        # Ensure row and row[0] are not None before converting
        if row and row[0] is not None:
            quantity = int(row[0])
    except sqlite3.Error as e:
        # Log specific item ID in error message
        print(f"Error getting quantity for item {item_id}: {e}")
    except Exception as e_gen: # Catch potential non-SQLite errors
         print(f"Unexpected error getting quantity for item {item_id}: {e_gen}")
    return quantity

 
import sqlite3
from datetime import datetime, timedelta

# Connect to SQLite database (creates if not exists)
conn = sqlite3.connect('C://JBB//data//krar.db')
cursor = conn.cursor()


# Create tables
cursor.execute('''
    CREATE TABLE IF NOT EXISTS all_krar (
        krar_id INTEGER PRIMARY KEY AUTOINCREMENT,
        customer_id INTEGER,
        is_nill INTEGER DEFAULT 0
    )
''')

cursor.execute('''
    CREATE TABLE IF NOT EXISTS by_krar_id (
        uid INTEGER PRIMARY KEY AUTOINCREMENT,
        kid INTEGER,
        date TEXT,
        FOREIGN KEY(kid) REFERENCES all_krar(krar_id)
    )
''')


# Function to add a new krar for a customer with checks for existing unsettled krar
def add_or_update_krar(customer_id, date):
    # Check if there's an unsettled krar for the customer
    cursor.execute('''
        SELECT krar_id FROM all_krar WHERE customer_id = ? AND is_nill = 0
    ''', (customer_id,))
    unsettled_krar = cursor.fetchone()

    if unsettled_krar:
        # If unsettled krar exists, get its krar_id and update 'by_krar_id' table
        krar_id = unsettled_krar[0]
        cursor.execute('''
            INSERT INTO by_krar_id (kid, date) VALUES (?, ?)
        ''', (krar_id, date))
        conn.commit()
        return krar_id
    else:
        # If no unsettled krar exists, add a new krar for the customer
        cursor.execute('''
            INSERT INTO all_krar (customer_id) VALUES (?)
        ''', (customer_id,))
        krar_id = cursor.lastrowid

        cursor.execute('''
            INSERT INTO by_krar_id (kid, date) VALUES (?, ?)
        ''', (krar_id, date))
        conn.commit()
        return krar_id



# Function to fetch details of unsettled krar for a customer
def get_unsettled_krar_dates(customer_id):
    cursor.execute('''
        SELECT b.date
        FROM all_krar a
        JOIN by_krar_id b ON a.krar_id = b.kid
        WHERE a.customer_id = ? AND a.is_nill = 0
    ''', (customer_id,))
    unsettled_dates = cursor.fetchall()
    return [date[0] for date in unsettled_dates]



# Function to fetch details of settled krar for a customer
def get_settled_krar_details(customer_id):
    cursor.execute('''
        SELECT a.krar_id, COUNT(*), MIN(b.date), MAX(b.date)
        FROM all_krar a
        JOIN by_krar_id b ON a.krar_id = b.kid
        WHERE a.customer_id = ? AND a.is_nill = 1
        GROUP BY a.krar_id
    ''', (customer_id,))
    settled_krar_details = cursor.fetchall()
    return settled_krar_details


# Function to set the settlement of krar by customer_id
def set_krar_settlement(customer_id):
    cursor.execute('''
        UPDATE all_krar SET is_nill = 1 WHERE customer_id = ? AND is_nill = 0
    ''', (customer_id,))
    conn.commit()

def modify_krar_customer_and_status(krar_id, new_customer_id, new_is_nill):
    cursor.execute('''
        UPDATE all_krar SET customer_id = ?, is_nill = ? WHERE krar_id = ?
    ''', (new_customer_id, new_is_nill, krar_id))
    conn.commit()


def modify_by_krar_id(uid, new_kid, new_date):
    cursor.execute('''
        UPDATE by_krar_id SET kid = ?, date = ? WHERE uid = ?
    ''', (new_kid, new_date, uid))
    conn.commit()



def delete_from_all_krar(krar_id):
    cursor.execute('''
        DELETE FROM by_krar_id WHERE kid = ?
    ''', (krar_id,))
    cursor.execute('''
        DELETE FROM all_krar WHERE krar_id = ?
    ''', (krar_id,))
    conn.commit()


def delete_from_by_krar_id(uid):
    cursor.execute('''
        DELETE FROM by_krar_id WHERE uid = ?
    ''', (uid,))
    conn.commit()

def get_accounts_with_unsettled_krars():
    cursor.execute('''
        SELECT DISTINCT customer_id
        FROM all_krar
        WHERE is_nill = 0
    ''')
    unsettled_accounts = cursor.fetchall()
    return [account[0] for account in unsettled_accounts]


def get_customers_with_last_krar_today():
    today = datetime.now().date()
    cursor.execute('''
        SELECT DISTINCT a.customer_id
        FROM all_krar a
        JOIN by_krar_id b ON a.krar_id = b.kid
        WHERE DATE(b.date) = ? AND DATE(b.date) = (SELECT MAX(DATE(date)) FROM by_krar_id WHERE kid = a.krar_id) AND is_nill = 0
    ''', (today,))
    customers_today = cursor.fetchall()
    return [customer[0] for customer in customers_today]


def get_customers_with_last_krar_past():
    today = datetime.now().date()
    cursor.execute('''
        SELECT DISTINCT a.customer_id
        FROM all_krar a
        JOIN by_krar_id b ON a.krar_id = b.kid
        WHERE DATE(b.date) < ? AND DATE(b.date) = (SELECT MAX(DATE(date)) FROM by_krar_id WHERE kid = a.krar_id) AND is_nill = 0
    ''', (today,))
    customers_past = cursor.fetchall()
    return [customer[0] for customer in customers_past]

def get_customers_with_last_krar_future():
    today = datetime.now().date()
    cursor.execute('''
        SELECT DISTINCT a.customer_id
        FROM all_krar a
        JOIN by_krar_id b ON a.krar_id = b.kid
        WHERE DATE(b.date) > ? AND DATE(b.date) = (SELECT MAX(DATE(date)) FROM by_krar_id WHERE kid = a.krar_id) AND is_nill = 0
    ''', (today,))
    customers_future = cursor.fetchall()
    return [customer[0] for customer in customers_future]

 

 
import tkinter as tk
# from tkinter import ttk
from datetime import datetime

from .mytheme import Colors

from database import accounts, database
# import accounts
# import database
# from inventory import
# from sales import Sales

class AccountPage(tk.Frame):
    def __init__(self, master, **kwargs):
        super().__init__(master, **kwargs)

        APP_FONT = "Consolas 12"
        APP_FONT1 = "Consolas 14"

        # main frame to include all frames
        self.main_frame = tk.Frame(self, bg=Colors.BACKGROUND)
        self.main_frame.place(relx=0.3, rely=0.01, relwidth=.4, relheight=.98)


        title_frame = tk.Frame(self.main_frame, bg=Colors.BACKGROUND1)
        title_frame.pack(fill='x', pady=2, padx=10)
        title_name_label = tk.Label(title_frame, text="Account", font="Consolas 18", bg=Colors.BACKGROUND1, fg=Colors.FG_SHADE_3, anchor='center')
        title_name_label.pack(padx=40, fill='x')

        # Name Entry Box
        name_frame = tk.Frame(self.main_frame, bg=Colors.BACKGROUND)
        name_frame.pack(fill='x', pady=10, padx=10)

        name_label = tk.Label(name_frame, text="Name", font=APP_FONT, bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND, anchor='w')
        name_label.pack(padx=40, fill='x')
        self.name_entry = tk.Entry(name_frame, font=APP_FONT1, bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_1, relief='solid')
        self.name_entry.pack(padx=40, pady=(0,10), fill='x')

        # Other Details Entry Box
        details_frame = tk.Frame(self.main_frame, bg=Colors.BACKGROUND)
        details_frame.pack(fill='x', pady=10, padx=10)
        details_label = tk.Label(details_frame, text="Other Details", font=APP_FONT, bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND, anchor='w')
        details_label.pack(padx=40, fill='x')
        self.details_entry = tk.Entry(details_frame, font=APP_FONT1, bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_1, relief='solid')
        self.details_entry.pack(padx=40, pady=(0,10), fill='x')

        # Date Entry Box
        date_frame = tk.Frame(self.main_frame, bg=Colors.BACKGROUND)
        date_frame.pack(fill='x', pady=10, padx=10)
        date_label = tk.Label(date_frame, text="Date", font=APP_FONT, bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND, anchor='w')
        date_label.pack(padx=40, fill='x')
        self.date_entry = tk.Entry(date_frame, font=APP_FONT1, bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_1, relief='solid')
        self.date_entry.pack(padx=40, pady=(0,10), fill='x')
        self.date_entry.insert(0, datetime.today().strftime('%Y-%m-%d'))

        # Opening Balance Entry Box
        balance_frame = tk.Frame(self.main_frame, bg=Colors.BACKGROUND)
        balance_frame.pack(fill='x', pady=10, padx=10)
        balance_label = tk.Label(balance_frame, text="Opening Balance", font=APP_FONT, bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND, anchor='w')
        balance_label.pack(padx=40, fill='x')
        self.balance_entry = tk.Entry(balance_frame, font=APP_FONT1, bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_1, relief='solid')
        self.balance_entry.pack(padx=40, pady=(0,10), fill='x')
        
        # Status Entry Box
        status_frame = tk.Frame(self.main_frame, bg=Colors.BACKGROUND)
        status_frame.pack(fill='x', pady=10, padx=10)
        status_label = tk.Label(status_frame, text="Source | P/M | TAG 1", font=APP_FONT, bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND, anchor='w')
        status_label.pack(padx=40, fill='x')
        self.status_entry = tk.Entry(status_frame, font=APP_FONT1, bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_1, relief='solid')
        self.status_entry.insert(0, "New Account")
        self.status_entry.pack(padx=40, pady=(0,10), fill='x')
        self.pm_entry = tk.Entry(status_frame, font=APP_FONT1, bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_1, relief='solid')
        self.pm_entry.insert(0, "P")
        self.pm_entry.pack(padx=40, pady=(0,10), fill='x')
        self.tag_entry = tk.Entry(status_frame, font=APP_FONT1, bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_1, relief='solid')
        self.tag_entry.insert(0, "1")
        self.tag_entry.pack(padx=40, pady=(0,10), fill='x')

        # Add Account Button
        button_frame = tk.Frame(self.main_frame, bg=Colors.BACKGROUND)
        button_frame.pack(fill='x', pady=(10,0), padx=10)
        self.add_button = tk.Button(button_frame, text="Add Account", font=APP_FONT1, command=self.add_account, bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_3, relief='solid')
        self.add_button.pack(padx=40, fill='x', pady=(10, 10))


    def add_account(self):
        name = self.name_entry.get().upper()
        date = self.date_entry.get().upper()
        details = self.details_entry.get().upper()
        opening_balance = self.balance_entry.get()
        status_entry = self.status_entry.get().upper()
        pm_entry = self.pm_entry.get().upper()
        tag_entry = self.tag_entry.get().upper()

        # verify entry
        if name and date and details and status_entry and pm_entry and tag_entry:
            a = accounts.add_new_customer(name, details)
            accounts.add_customer_transaction(a, date, status_entry, opening_balance, pm_entry, tag_entry)
            dailynote = f"01 = {name}, {date}, {details}, {opening_balance}, {status_entry}, {pm_entry}, {tag_entry}"
            database.add_note_to_date(dailynote)

            if __name__ != "__main__":
                self.master.master.set_status(f"Account added: {a}")

        else:
            if __name__ == "__main__":
                print("Some fields are empty")
            else:
                self.master.master.set_status("[-]|Some fields are empty|")

        # add account to database
        # (code for this would depend on how you implemented your accounts database)


if __name__ == "__main__":
    app = tk.Tk()
    app.state("zoomed")
    a = AccountPage(app)
    a.pack(expand=1, fill="both")
    app.mainloop()

 
# gui/crop_trading.py
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
from datetime import datetime

from .mytheme import Colors
from .searchbar import SearchBar
from database import crop_database # Keep this import

class CropTradingPage(tk.Frame):
    def __init__(self, master, **kwargs):
        super().__init__(master, **kwargs)
        self.configure(bg=Colors.BACKGROUND)

        # --- Main Layout Frames ---
        self.top_frame = tk.Frame(self, bg=Colors.BACKGROUND)
        self.top_frame.pack(fill=tk.X, padx=5, pady=(5,0)) # Frame for Mgmt and Transactions

        self.report_frame = tk.Frame(self, bg=Colors.BACKGROUND, bd=1, relief=tk.GROOVE)
        self.report_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=(5,5)) # Frame for Reports

        # Use PanedWindow inside top_frame for adjustable Mgmt/Transaction sections
        self.paned_window = tk.PanedWindow(self.top_frame, orient=tk.HORIZONTAL, sashrelief=tk.RAISED, bg=Colors.BACKGROUND)
        self.paned_window.pack(fill=tk.BOTH, expand=True)

        # --- Populate PanedWindow ---
        # Frame for Management (Farmers, Crops)
        self.mgmt_frame = tk.Frame(self.paned_window, bg=Colors.BACKGROUND, bd=1, relief=tk.SUNKEN, padx=5)
        self.paned_window.add(self.mgmt_frame, width=250, stretch="never")

        # Frame for Transactions (Purchase, Sale)
        self.trans_frame = tk.Frame(self.paned_window, bg=Colors.BACKGROUND)
        self.paned_window.add(self.trans_frame)

        # --- Populate Frames ---
        self.create_mgmt_widgets() # In mgmt_frame

        # Put Purchase/Sale inside trans_frame
        self.purchase_frame = tk.LabelFrame(self.trans_frame, text="Record Purchase", padx=10, pady=10,
                                            bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND,
                                            font=("Consolas", 14))
        self.purchase_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=10, pady=5)

        self.sale_frame = tk.LabelFrame(self.trans_frame, text="Record Sale", padx=10, pady=10,
                                        bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND,
                                        font=("Consolas", 14))
        self.sale_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=10, pady=5)

        self.create_purchase_widgets() # In purchase_frame
        self.create_sale_widgets()     # In sale_frame

        # --- Populate Report Frame ---
        self.create_report_widgets()   # In report_frame

        # --- Initial Data Load ---
        self.refresh_all_lists()
        self.show_crop_report() # Show default report (e.g., stock summary)


    # --- Management Widgets (No Change) ---
    def create_mgmt_widgets(self):
        # ... (Keep implementation from previous correct version) ...
        mgmt_title = tk.Label(self.mgmt_frame, text="Manage", font=("Consolas", 16, "bold"), bg=Colors.BACKGROUND1, fg=Colors.FG_SHADE_3); mgmt_title.pack(fill=tk.X, pady=(0, 10))
        farmer_frame = tk.LabelFrame(self.mgmt_frame, text="Add Farmer", padx=5, pady=5, bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND); farmer_frame.pack(fill=tk.X, padx=5, pady=5)
        self.new_farmer_name_var = tk.StringVar(); self.new_farmer_details_var = tk.StringVar()
        tk.Label(farmer_frame, text="Name:", bg=Colors.BACKGROUND, fg=Colors.FOREGROUND).grid(row=0, column=0, sticky='w', pady=2)
        tk.Entry(farmer_frame, textvariable=self.new_farmer_name_var, font="Consolas 12", width=20, bg=Colors.BACKGROUND3, fg=Colors.FG_SHADE_1).grid(row=0, column=1, sticky='ew', pady=2, padx=5)
        tk.Label(farmer_frame, text="Details:", bg=Colors.BACKGROUND, fg=Colors.FOREGROUND).grid(row=1, column=0, sticky='w', pady=2)
        tk.Entry(farmer_frame, textvariable=self.new_farmer_details_var, font="Consolas 12", width=20, bg=Colors.BACKGROUND3, fg=Colors.FG_SHADE_1).grid(row=1, column=1, sticky='ew', pady=2, padx=5)
        tk.Button(farmer_frame, text="Add", font="Consolas 10", command=self.add_new_farmer_action, bg=Colors.BACKGROUND1, fg=Colors.SUCCESS).grid(row=2, column=0, columnspan=2, pady=5)
        farmer_frame.grid_columnconfigure(1, weight=1)
        crop_frame = tk.LabelFrame(self.mgmt_frame, text="Add Crop", padx=5, pady=5, bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND); crop_frame.pack(fill=tk.X, padx=5, pady=5)
        self.new_crop_name_var = tk.StringVar(); self.new_crop_unit_var = tk.StringVar(value="KG")
        tk.Label(crop_frame, text="Name:", bg=Colors.BACKGROUND, fg=Colors.FOREGROUND).grid(row=0, column=0, sticky='w', pady=2)
        tk.Entry(crop_frame, textvariable=self.new_crop_name_var, font="Consolas 12", width=20, bg=Colors.BACKGROUND3, fg=Colors.FG_SHADE_1).grid(row=0, column=1, sticky='ew', pady=2, padx=5)
        tk.Label(crop_frame, text="Unit:", bg=Colors.BACKGROUND, fg=Colors.FOREGROUND).grid(row=1, column=0, sticky='w', pady=2)
        tk.Entry(crop_frame, textvariable=self.new_crop_unit_var, font="Consolas 12", width=20, bg=Colors.BACKGROUND3, fg=Colors.FG_SHADE_1).grid(row=1, column=1, sticky='ew', pady=2, padx=5)
        tk.Button(crop_frame, text="Add", font="Consolas 10", command=self.add_new_crop_action, bg=Colors.BACKGROUND1, fg=Colors.SUCCESS).grid(row=2, column=0, columnspan=2, pady=5)
        crop_frame.grid_columnconfigure(1, weight=1)

    # --- Actions for Management Widgets (No Change) ---
    def add_new_farmer_action(self):
        # ... (Keep implementation from previous correct version) ...
        name = self.new_farmer_name_var.get().strip().upper(); details = self.new_farmer_details_var.get().strip().upper()
        if not name: messagebox.showwarning("Input Missing", "Farmer Name cannot be empty."); return
        farmer_id = crop_database.add_farmer(name, details)
        if farmer_id: self._set_status(f"Farmer '{name}' added (ID: {farmer_id})."); self.new_farmer_name_var.set(""); self.new_farmer_details_var.set(""); self.refresh_purchase_lists()
        elif farmer_id is None: self._set_status(f"[Warning/Error] Could not add farmer '{name}'. Check console.")

    def add_new_crop_action(self):
        # ... (Keep implementation from previous correct version) ...
        name = self.new_crop_name_var.get().strip().upper(); unit = self.new_crop_unit_var.get().strip().upper() or "KG"
        if not name: messagebox.showwarning("Input Missing", "Crop Name cannot be empty."); return
        crop_id = crop_database.add_crop(name, unit)
        if crop_id: self._set_status(f"Crop '{name}' added (ID: {crop_id})."); self.new_crop_name_var.set(""); self.new_crop_unit_var.set("KG"); self.refresh_all_lists()
        elif crop_id is None: self._set_status(f"[Warning/Error] Could not add crop '{name}'. Check console.")


    # --- Helper to create input rows (No Change) ---
    def _create_input_row(self, parent, label_text, entry_var=None, widget_type='entry', dropdown_options=None, use_searchbar=False):
        # ... (Keep implementation from previous correct version) ...
        frame = tk.Frame(parent, bg=Colors.BACKGROUND); frame.pack(fill=tk.X, pady=5)
        label = tk.Label(frame, text=label_text, font="Consolas 12", width=15, anchor='w', bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND); label.pack(side=tk.LEFT, padx=(0, 10))
        widget = None
        if use_searchbar and dropdown_options is not None:
             widget = SearchBar(frame, data=dropdown_options); widget.set_data(dropdown_options); widget.pack(side=tk.LEFT, fill=tk.X, expand=True)
        elif widget_type == 'entry':
            widget = tk.Entry(frame, textvariable=entry_var, font="Consolas 14", bg=Colors.BACKGROUND3, fg=Colors.FG_SHADE_1, relief='solid', bd=1); widget.pack(side=tk.LEFT, fill=tk.X, expand=True)
        elif widget_type == 'combobox' and dropdown_options is not None:
             widget = ttk.Combobox(frame, textvariable=entry_var, values=dropdown_options, font="Consolas 14", state="readonly"); widget.pack(side=tk.LEFT, fill=tk.X, expand=True)
             if dropdown_options: widget.current(0)
        return widget

    # --- Purchase Widgets (No Change) ---
    def create_purchase_widgets(self):
        # ... (Keep implementation from previous correct version) ...
        self.p_date_var = tk.StringVar(value=datetime.now().strftime('%Y-%m-%d')); self.p_net_qty_var = tk.StringVar(); self.p_k_qty_var = tk.StringVar(value="0"); self.p_rate_var = tk.StringVar(); self.p_actual_qty_var = tk.StringVar(value="Calculated..."); self.p_total_amt_var = tk.StringVar(value="Calculated...")
        self._create_input_row(self.purchase_frame, "Date:", self.p_date_var)
        self.p_farmer_searchbar = self._create_input_row(self.purchase_frame, "Farmer:", dropdown_options=[], use_searchbar=True)
        self.p_crop_searchbar = self._create_input_row(self.purchase_frame, "Crop:", dropdown_options=[], use_searchbar=True)
        net_entry = self._create_input_row(self.purchase_frame, "Net Qty:", self.p_net_qty_var); k_entry = self._create_input_row(self.purchase_frame, "K-Qty:", self.p_k_qty_var); rate_entry = self._create_input_row(self.purchase_frame, "Rate:", self.p_rate_var)
        net_entry.bind("<KeyRelease>", self.calculate_purchase_totals); k_entry.bind("<KeyRelease>", self.calculate_purchase_totals); rate_entry.bind("<KeyRelease>", self.calculate_purchase_totals)
        calc_frame = tk.Frame(self.purchase_frame, bg=Colors.BACKGROUND); calc_frame.pack(fill=tk.X, pady=5); tk.Label(calc_frame, text="Actual Qty:", font="Consolas 12", width=15, anchor='w', bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND).pack(side=tk.LEFT, padx=(0, 10)); tk.Label(calc_frame, textvariable=self.p_actual_qty_var, font="Consolas 14 bold", anchor='w', bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_3).pack(side=tk.LEFT, fill=tk.X, expand=True)
        calc_frame2 = tk.Frame(self.purchase_frame, bg=Colors.BACKGROUND); calc_frame2.pack(fill=tk.X, pady=5); tk.Label(calc_frame2, text="Total Amount:", font="Consolas 12", width=15, anchor='w', bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND).pack(side=tk.LEFT, padx=(0, 10)); tk.Label(calc_frame2, textvariable=self.p_total_amt_var, font="Consolas 14 bold", anchor='w', bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_3).pack(side=tk.LEFT, fill=tk.X, expand=True)
        tk.Button(self.purchase_frame, text="Record Purchase", font="Consolas 14", command=self.record_purchase_action, bg=Colors.BACKGROUND1, fg=Colors.SUCCESS, relief='raised', bd=2).pack(pady=15, fill=tk.X)
        tk.Button(self.purchase_frame, text="Refresh Lists", font="Consolas 10", command=self.refresh_all_lists, bg=Colors.BACKGROUND2, fg=Colors.ACTIVE_FOREGROUND, relief='raised', bd=1).pack(pady=5, side=tk.BOTTOM)

    # --- Sale Widgets (No Change) ---
    def create_sale_widgets(self):
        # ... (Keep implementation from previous correct version) ...
        self.s_date_var = tk.StringVar(value=datetime.now().strftime('%Y-%m-%d')); self.s_qty_var = tk.StringVar(); self.s_rate_var = tk.StringVar(); self.s_buyer_var = tk.StringVar(); self.s_total_amt_var = tk.StringVar(value="Calculated...")
        self._create_input_row(self.sale_frame, "Date:", self.s_date_var)
        self.s_crop_searchbar = self._create_input_row(self.sale_frame, "Crop:", dropdown_options=[], use_searchbar=True)
        qty_entry = self._create_input_row(self.sale_frame, "Sale Qty:", self.s_qty_var); rate_entry = self._create_input_row(self.sale_frame, "Rate:", self.s_rate_var); self._create_input_row(self.sale_frame, "Buyer Details:", self.s_buyer_var)
        qty_entry.bind("<KeyRelease>", self.calculate_sale_total); rate_entry.bind("<KeyRelease>", self.calculate_sale_total)
        calc_frame_s = tk.Frame(self.sale_frame, bg=Colors.BACKGROUND); calc_frame_s.pack(fill=tk.X, pady=5); tk.Label(calc_frame_s, text="Total Amount:", font="Consolas 12", width=15, anchor='w', bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND).pack(side=tk.LEFT, padx=(0, 10)); tk.Label(calc_frame_s, textvariable=self.s_total_amt_var, font="Consolas 14 bold", anchor='w', bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_3).pack(side=tk.LEFT, fill=tk.X, expand=True)
        tk.Button(self.sale_frame, text="Record Sale", font="Consolas 14", command=self.record_sale_action, bg=Colors.BACKGROUND1, fg=Colors.SUCCESS, relief='raised', bd=2).pack(pady=15, fill=tk.X, side=tk.BOTTOM)
        tk.Button(self.sale_frame, text="Refresh Lists", font="Consolas 10", command=self.refresh_all_lists, bg=Colors.BACKGROUND2, fg=Colors.ACTIVE_FOREGROUND, relief='raised', bd=1).pack(pady=5, side=tk.BOTTOM)

    # --- Formatting for SearchBar (No Change) ---
    def _format_for_searchbar(self, data_list, id_index, name_index):
        # ... (Keep implementation from previous correct version) ...
        if not data_list: return []; return [f"{item[id_index]} {item[name_index]}" for item in data_list]

    # --- Refresh Dropdown/SearchBar Data (No Change) ---
    def refresh_purchase_lists(self):
        # ... (Keep implementation from previous correct version) ...
        farmer_list = self._format_for_searchbar(crop_database.get_farmers(), 0, 1); crop_list = self._format_for_searchbar(crop_database.get_crops(), 0, 1)
        if self.p_farmer_searchbar: self.p_farmer_searchbar.set_data(farmer_list)
        if self.p_crop_searchbar: self.p_crop_searchbar.set_data(crop_list)
        # self._set_status("Purchase lists refreshed.") # Can be combined in refresh_all_lists

    def refresh_sale_lists(self):
        # ... (Keep implementation from previous correct version) ...
        crop_list = self._format_for_searchbar(crop_database.get_crops(), 0, 1)
        if self.s_crop_searchbar: self.s_crop_searchbar.set_data(crop_list)
        # self._set_status("Sale crop list refreshed.") # Can be combined in refresh_all_lists

    def refresh_all_lists(self):
        # ... (Keep implementation from previous correct version) ...
        self.refresh_purchase_lists(); self.refresh_sale_lists()
        self._set_status("Farmer and Crop lists refreshed.")

    # --- Calculation Logic (No Change) ---
    def calculate_purchase_totals(self, event=None):
        # ... (Keep implementation from previous correct version) ...
         try:
             net_q=float(self.p_net_qty_var.get() or 0);k_q=float(self.p_k_qty_var.get() or 0);rate=float(self.p_rate_var.get() or 0)
             if k_q > net_q: raise ValueError("K>Net")
             actual_q=net_q-k_q; total_amt=actual_q*rate
             self.p_actual_qty_var.set(f"{actual_q:.2f}"); self.p_total_amt_var.set(f"{total_amt:.2f}")
         except ValueError as e: self.p_actual_qty_var.set(f"Error: {e}"); self.p_total_amt_var.set("Invalid Input")
         except Exception as e: print(f"Calc err: {e}"); self.p_actual_qty_var.set("Error"); self.p_total_amt_var.set("Error")

    def calculate_sale_total(self, event=None):
        # ... (Keep implementation from previous correct version) ...
         try: qty=float(self.s_qty_var.get() or 0); rate=float(self.s_rate_var.get() or 0); total_amt=qty*rate; self.s_total_amt_var.set(f"{total_amt:.2f}")
         except ValueError: self.s_total_amt_var.set("Invalid Input")
         except Exception as e: print(f"Sale calc err: {e}"); self.s_total_amt_var.set("Error")

    # --- Helper: Get ID or Add New (No Change) ---
    def _get_or_add_farmer(self, farmer_input_str):
        # ... (Keep implementation from previous correct version) ...
        farmer_input_str=farmer_input_str.strip().upper();
        if not farmer_input_str: return None
        farmers=crop_database.get_farmers(); farmer_map={f"{f[0]} {f[1]}": f[0] for f in farmers}; exact_match_map={f[1]: f[0] for f in farmers}
        if farmer_input_str in farmer_map: return farmer_map[farmer_input_str]
        if farmer_input_str in exact_match_map: return exact_match_map[farmer_input_str]
        msg=f"Farmer '{farmer_input_str}' not found.\nAdd this farmer?";
        if messagebox.askyesno("Add Farmer?", msg):
            details=simpledialog.askstring("Farmer Details", f"Details for '{farmer_input_str}' (optional):", parent=self) or ""
            farmer_id=crop_database.add_farmer(farmer_input_str, details)
            if farmer_id: self._set_status(f"Added new farmer '{farmer_input_str}' (ID: {farmer_id})"); self.refresh_purchase_lists(); self.p_farmer_searchbar.set_text(f"{farmer_id} {farmer_input_str}"); return farmer_id
            else: messagebox.showerror("Error", f"Failed to add farmer '{farmer_input_str}'."); return None
        else: return None

    def _get_or_add_crop(self, crop_input_str, target_searchbar):
        # ... (Keep implementation from previous correct version) ...
        crop_input_str=crop_input_str.strip().upper();
        if not crop_input_str: return None
        crops=crop_database.get_crops(); crop_map={f"{c[0]} {c[1]}": c[0] for c in crops}; exact_match_map={c[1]: c[0] for c in crops}
        if crop_input_str in crop_map: return crop_map[crop_input_str]
        if crop_input_str in exact_match_map: return exact_match_map[crop_input_str]
        msg=f"Crop '{crop_input_str}' not found.\nAdd this crop?";
        if messagebox.askyesno("Add Crop?", msg):
            unit=simpledialog.askstring("Crop Unit", f"Unit for '{crop_input_str}' (default KG):", parent=self) or "KG"
            crop_id=crop_database.add_crop(crop_input_str, unit.upper())
            if crop_id: self._set_status(f"Added new crop '{crop_input_str}' (ID: {crop_id})"); self.refresh_all_lists(); target_searchbar.set_text(f"{crop_id} {crop_input_str}"); return crop_id
            else: messagebox.showerror("Error", f"Failed to add crop '{crop_input_str}'."); return None
        else: return None

    # --- Action Methods (No Change) ---
    def record_purchase_action(self):
        # ... (Keep implementation from previous correct version) ...
        date_str=self.p_date_var.get(); farmer_input=self.p_farmer_searchbar.get_text(); crop_input=self.p_crop_searchbar.get_text(); net_qty_str=self.p_net_qty_var.get(); k_qty_str=self.p_k_qty_var.get(); rate_str=self.p_rate_var.get()
        try: datetime.strptime(date_str, '%Y-%m-%d')
        except ValueError: messagebox.showerror("Input Error", f"Invalid Date format: '{date_str}'. Use YYYY-MM-DD."); self._set_status("[Error] Invalid Date format."); return
        farmer_id=self._get_or_add_farmer(farmer_input)
        if farmer_id is None: self._set_status("[Cancelled/Error] Farmer ID process stopped."); self.p_farmer_searchbar.search_bar.focus(); return
        crop_id=self._get_or_add_crop(crop_input, self.p_crop_searchbar)
        if crop_id is None: self._set_status("[Cancelled/Error] Crop ID process stopped."); self.p_crop_searchbar.search_bar.focus(); return
        purchase_id, message = crop_database.record_purchase(farmer_id, crop_id, date_str, net_qty_str, k_qty_str, rate_str)
        if purchase_id: self._set_status(f"Purchase recorded (ID: {purchase_id}). {message}")
        else: messagebox.showerror("Database Error", f"Failed purchase record.\nReason: {message}"); self._set_status(f"[Error] Purchase failed: {message}")

    def record_sale_action(self):
        # ... (Keep implementation from previous correct version) ...
        date_str=self.s_date_var.get(); crop_input=self.s_crop_searchbar.get_text(); qty_str=self.s_qty_var.get(); rate_str=self.s_rate_var.get(); buyer_details=self.s_buyer_var.get()
        try: datetime.strptime(date_str, '%Y-%m-%d')
        except ValueError: messagebox.showerror("Input Error", f"Invalid Date format: '{date_str}'. Use YYYY-MM-DD."); self._set_status("[Error] Invalid Date format."); return
        crop_id=self._get_or_add_crop(crop_input, self.s_crop_searchbar)
        if crop_id is None: self._set_status("[Cancelled/Error] Crop ID process stopped."); self.s_crop_searchbar.search_bar.focus(); return
        sale_id, message = crop_database.record_sale(crop_id, date_str, qty_str, rate_str, buyer_details)
        if sale_id: self._set_status(f"Sale recorded (ID: {sale_id}). {message}")
        else: messagebox.showerror("Database Error", f"Failed sale record.\nReason: {message}"); self._set_status(f"[Error] Sale failed: {message}")

    # --- Status Update Helper (No Change) ---
    def _set_status(self, message):
        # ... (Keep implementation from previous correct version) ...
        try:
            if hasattr(self.master, 'master') and hasattr(self.master.master, 'set_status'): self.master.master.set_status(f"|Crop Trading| {message}")
            else: print(f"Crop Trading Status: {message}")
        except Exception as e: print(f"Status Update Error: {e}")


    # --- NEW: Report Widgets ---
    def create_report_widgets(self):
        """Creates the controls and display area for crop reports."""
        # Frame for Controls
        report_controls_frame = tk.Frame(self.report_frame, bg=Colors.BACKGROUND)
        report_controls_frame.pack(fill=tk.X, pady=(5, 2))

        tk.Label(report_controls_frame, text="Select Report:", bg=Colors.BACKGROUND,
                 fg=Colors.ACTIVE_FOREGROUND, font="Consolas 12").pack(side=tk.LEFT, padx=5)

        report_types = ["Stock Summary", "Purchase History", "Sales History"]
        self.report_type_var = tk.StringVar(value=report_types[0]) # Default to Stock Summary
        report_dropdown = ttk.Combobox(report_controls_frame, textvariable=self.report_type_var,
                                        values=report_types, width=20, font="Consolas 12", state="readonly")
        report_dropdown.pack(side=tk.LEFT, padx=5)
        report_dropdown.bind("<<ComboboxSelected>>", self.show_crop_report)

        # Optional: Add date filters or other filters here later

        show_button = tk.Button(report_controls_frame, text="Show Report", font="Consolas 11",
                                command=self.show_crop_report, bg=Colors.BACKGROUND1, fg=Colors.ACTIVE_FOREGROUND)
        show_button.pack(side=tk.LEFT, padx=10)

        # Frame for Treeview display
        self.report_display_frame = tk.Frame(self.report_frame, bg=Colors.BACKGROUND2) # Slightly different bg?
        self.report_display_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # Placeholder label for reports initially
        self.report_placeholder_label = tk.Label(self.report_display_frame,
                                                  text="Select a report to view.",
                                                  font="Consolas 14", bg=Colors.BACKGROUND2, fg=Colors.FOREGROUND)
        self.report_placeholder_label.pack(pady=20)


    # --- NEW: Clear Report Display ---
    def clear_report_frame(self):
        """Removes previous report Treeview and scrollbars."""
        for widget in self.report_display_frame.winfo_children():
            widget.destroy()


    # --- NEW: Show Crop Report ---
    def show_crop_report(self, event=None):
        """Fetches and displays the selected crop report."""
        report_type = self.report_type_var.get()
        self.clear_report_frame() # Clear previous report

        column_names = []
        column_widths = []
        report_data = []

        try:
            if report_type == "Stock Summary":
                column_names = ["Crop", "Unit", "Quantity", "Avg Cost", "Total Value"]
                column_widths = [150, 60, 100, 100, 120]
                report_data = crop_database.get_stock_summary()
                self._set_status("Displayed Stock Summary.")
            elif report_type == "Purchase History":
                column_names = ["ID", "Date", "Farmer", "Crop", "Net Q", "K Q", "Actual Q", "Rate", "Amount"]
                column_widths = [40, 90, 150, 120, 70, 70, 80, 80, 100]
                report_data = crop_database.get_purchase_history() # Add filters later
                self._set_status("Displayed Purchase History.")
            elif report_type == "Sales History":
                column_names = ["ID", "Date", "Crop", "Sale Q", "Rate", "Amount", "Buyer"]
                column_widths = [40, 90, 120, 80, 80, 100, 150]
                report_data = crop_database.get_sales_history() # Add filters later
                self._set_status("Displayed Sales History.")
            else:
                self._set_status(f"Unknown report type: {report_type}")
                return # Should not happen with Combobox

        except Exception as e:
             self._set_status(f"[Error] Failed to fetch report data: {e}")
             print(f"Error fetching report '{report_type}': {e}")
             tk.Label(self.report_display_frame, text=f"Error loading report:\n{e}",
                      font="Consolas 12", fg="red", bg=Colors.BACKGROUND2).pack(pady=20)
             return


        # Display data if found
        if not report_data:
            tk.Label(self.report_display_frame, text=f"No data found for {report_type}.",
                     font="Consolas 14", bg=Colors.BACKGROUND2, fg=Colors.FOREGROUND).pack(pady=20)
            return

        # Create Treeview
        report_tree = ttk.Treeview(self.report_display_frame, columns=column_names, show='headings')

        # Configure Columns & Headings
        report_tree.column('#0', width=0, stretch='no') # Hide default column
        for i, col_name in enumerate(column_names):
            width = column_widths[i] if i < len(column_widths) else 100 # Default width
            report_tree.column(col_name, width=width, anchor='w', stretch=True)
            report_tree.heading(col_name, text=col_name, anchor='w')
            # Add sorting later if desired, using a similar function to reports.py

        # Insert Data
        for i, row in enumerate(report_data):
            tag = 'even_rep' if i % 2 == 0 else 'odd_rep'
            try:
                # Ensure row length matches columns
                values_to_insert = list(row); padding = len(column_names) - len(values_to_insert)
                if padding > 0: values_to_insert.extend([''] * padding)
                elif padding < 0: values_to_insert = values_to_insert[:len(column_names)]
                report_tree.insert('', 'end', values=values_to_insert, tags=(tag,))
            except Exception as e_insert:
                print(f"Error inserting report row {i+1}: {row}\n{e_insert}")


        # Configure Row Tags (use different names than main reports)
        report_tree.tag_configure('odd_rep', background=Colors.BACKGROUND, foreground=Colors.FOREGROUND)
        report_tree.tag_configure('even_rep', background=Colors.BACKGROUND1, foreground=Colors.FOREGROUND)

        # Scrollbars
        rep_yscroll = ttk.Scrollbar(self.report_display_frame, orient=tk.VERTICAL, command=report_tree.yview)
        rep_xscroll = ttk.Scrollbar(self.report_display_frame, orient=tk.HORIZONTAL, command=report_tree.xview)
        report_tree.configure(yscrollcommand=rep_yscroll.set, xscrollcommand=rep_xscroll.set)

        # Pack Treeview and Scrollbars
        rep_yscroll.pack(side=tk.RIGHT, fill=tk.Y)
        rep_xscroll.pack(side=tk.BOTTOM, fill=tk.X)
        report_tree.pack(fill=tk.BOTH, expand=True)


# --- Main execution for testing ---
if __name__ == "__main__":
    # ... (Test code remains the same) ...
    app = tk.Tk()
    app.title("Crop Trading Page Test w/ Reports")
    app.geometry("1100x750") # Wider/Taller for reports
    class MockMaster:
         def set_status(self, msg): print(f"Status Bar: {msg}")
    class MockApp: master = MockMaster()

    crop_database.initialize_database()

    page = CropTradingPage(app)
    page.master.master = MockApp()
    page.pack(fill=tk.BOTH, expand=True)
    app.mainloop()
 
# gui/homepage.py
import tkinter as tk
from tkinter import ttk, font as tkfont
import pandas as pd
import numpy as np
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure
import matplotlib.pyplot as plt

# Assuming these imports are correct relative to homepage.py
from .mytheme import Colors
# Import all needed database modules
from database import accounts, inventory, database as daily_db, krar, crop_database

# Helper function (keep as is)
def create_card_frame(parent, text="", **kwargs):
    frame = ttk.LabelFrame(parent, text=text, padding=(10, 5), style='Card.TLabelframe', **kwargs)
    return frame

class HomePage(tk.Frame):

    def __init__(self, master, **kwargs):
        super().__init__(master, bg=Colors.BACKGROUND, **kwargs) # Set main background
        self.Colors = Colors # Store theme colors
        self.accounts_df = pd.DataFrame() # Initialize empty dataframe

        # --- Configure Styles (Add styles for new elements) ---
        self.style = ttk.Style(self)
        self.style.configure('Card.TLabelframe', background=Colors.BACKGROUND1, borderwidth=1, relief=tk.GROOVE)
        self.style.configure('Card.TLabelframe.Label', background=Colors.BACKGROUND1, foreground=Colors.ACTIVE_FOREGROUND, font=("Consolas", 12, "bold"))
        self.style.configure('KPI.TLabel', background=Colors.BACKGROUND1, foreground=Colors.FG_SHADE_1, font=("Consolas", 16, "bold"), anchor='center', padding=(0, 2)) # Adjusted KPI font/padding
        self.style.configure('KPITitle.TLabel', background=Colors.BACKGROUND1, foreground=Colors.FOREGROUND, font=("Consolas", 9), anchor='center') # Smaller KPI title
        self.style.configure('GraphTitle.TLabel', background=Colors.BACKGROUND1, foreground=Colors.FG_SHADE_3, font=("Consolas", 11, "bold"), anchor='center')

        # Treeview Styles (ensure applied correctly)
        self.style.configure('Treeview', background=Colors.BACKGROUND2, fieldbackground=Colors.BACKGROUND2, foreground=Colors.FOREGROUND, borderwidth=0)
        self.style.configure('Treeview.Heading', background=Colors.BG_SHADE_1, foreground=Colors.FG_SHADE_3, font='Consolas 10 bold', relief='flat')
        self.style.map('Treeview.Heading', relief=[('active','groove')]) # Simple hover effect
        self.style.map('Treeview', background=[('selected', Colors.ACTIVE_BACKGROUND)], foreground=[('selected', Colors.FG_SHADE_1)])

        # Style for the new lists (Low Stock, Crop Stock)
        self.style.configure('List.Treeview', background=Colors.BACKGROUND2, fieldbackground=Colors.BACKGROUND2, foreground=Colors.FOREGROUND)
        self.style.configure('List.Treeview.Heading', background=Colors.BG_SHADE_1, foreground=Colors.ACTIVE_FOREGROUND, font='Consolas 9 bold') # Slightly different heading

        # Notebook style
        self.style.configure("TNotebook", background=Colors.BACKGROUND, borderwidth=0)
        self.style.configure("TNotebook.Tab", background=Colors.BACKGROUND1, foreground=Colors.FOREGROUND, padding=[8, 3], font=('Consolas', 10))
        self.style.map("TNotebook.Tab", background=[("selected", Colors.ACTIVE_BACKGROUND)], foreground=[("selected", Colors.FG_SHADE_1)])

        # Refresh Button Style
        self.style.configure("Refresh.TButton", font=("Consolas", 10), padding=5)
        self.style.map("Refresh.TButton",
                       background=[('active', Colors.LIGHT_BG), ('!active', Colors.BACKGROUND1)],
                       foreground=[('active', Colors.ACTIVE_FOREGROUND)])


        # --- Main Layout Frames ---
        self.grid_rowconfigure(0, weight=0) # Row 0 for KPIs & Refresh (fixed height)
        self.grid_rowconfigure(1, weight=1) # Row 1 expands (Graphs/Activity)
        self.grid_columnconfigure(0, weight=2) # Left column (graphs)
        self.grid_columnconfigure(1, weight=1) # Right column (Krar/Activity)

        # --- Top Bar Frame (KPIs + Refresh) ---
        self.top_bar_frame = tk.Frame(self, bg=Colors.BACKGROUND)
        self.top_bar_frame.grid(row=0, column=0, columnspan=2, sticky="ew", padx=5, pady=(5,0))
        # Add Refresh button here
        self.refresh_button = ttk.Button(self.top_bar_frame, text="↻ Refresh",
                                        command=self.trigger_refresh, style="Refresh.TButton")
        self.refresh_button.pack(side=tk.RIGHT, padx=10, pady=5)

        # Frame for KPIs within the top bar
        self.kpi_frame = tk.Frame(self.top_bar_frame, bg=Colors.BACKGROUND)
        self.kpi_frame.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)


        # --- Bottom Frames (Graphs/Activity) ---
        self.financial_frame = tk.Frame(self, bg=Colors.BACKGROUND)
        self.financial_frame.grid(row=1, column=0, sticky="nsew", padx=(5,2), pady=5)

        self.activity_frame = tk.Frame(self, bg=Colors.BACKGROUND)
        self.activity_frame.grid(row=1, column=1, sticky="nsew", padx=(2,5), pady=5)

        # --- Initial Loading State ---
        self.loading_label = ttk.Label(self, text="Loading Dashboard Data...",
                                      font="Consolas 24 bold", background=Colors.BACKGROUND,
                                      foreground=Colors.FOREGROUND, anchor='center')
        self.loading_label.place(relx=0.5, rely=0.5, anchor='center') # Centered

    def trigger_refresh(self):
        """Calls the main application's data refresh mechanism."""
        if hasattr(self.master, 'master') and hasattr(self.master.master, 'my_parallel_processes'):
            print("Triggering dashboard refresh...")
            # Show loading label temporarily
            self.loading_label.place(relx=0.5, rely=0.5, anchor='center')
            self.update_idletasks() # Ensure label is shown
            # Call the main app's refresh function (assuming it handles background loading)
            # If my_parallel_processes is blocking, this needs to be run in a thread from main.py
            try:
                self.master.master.my_parallel_processes()
                # Loading label will be hidden by all_graphs_function when data arrives
            except Exception as e:
                 print(f"Error during triggered refresh: {e}")
                 self.loading_label.place_forget() # Hide loading on error too
                 # Optionally show an error message on the dashboard
        else:
            print("Refresh function not found in main application.")

    def _clear_frame(self, frame):
        for widget in frame.winfo_children():
            widget.destroy()

    def all_graphs_function(self, accounts_df):
        self.loading_label.place_forget()

        if accounts_df.empty:
            self._clear_frame(self.kpi_frame)
            self._clear_frame(self.financial_frame)
            self._clear_frame(self.activity_frame)
            error_label = ttk.Label(self, text="No Account Data Found",
                                   font="Consolas 20", background=Colors.BACKGROUND,
                                   foreground=Colors.ERROR, anchor='center')
            error_label.place(relx=0.5, rely=0.5, anchor='center')
            return

        self.accounts_df = accounts_df

        self.all_positive_df = self.accounts_df.loc[self.accounts_df['Amount'] >= 0].copy()
        self.all_negative_df = self.accounts_df.loc[self.accounts_df['Amount'] < 0].copy()

        # --- Fetch Additional Data ---
        self.inventory_total_value = inventory.get_total_inventory_value()
        self.low_stock_data = inventory.get_low_stock_items(threshold=10) # Example threshold
        self.crop_summary_data = crop_database.get_stock_summary() # Get crop data
        self.today_notes_count = daily_db.get_todays_notes_summary()

        # --- Populate Sections ---
        # Clear only frames that will be repopulated
        self._clear_frame(self.kpi_frame) # KPIs need recalculating
        self._clear_frame(self.financial_frame)
        self._clear_frame(self.activity_frame)

        self.create_kpi_cards()
        self.create_financial_graphs()
        self.create_activity_section() # This now includes Inventory/Crop lists

    def create_kpi_cards(self):
        # Calculate KPIs
        total_receivables = round(self.all_positive_df['Amount'].sum(), 2)
        total_payables = round(self.all_negative_df['Amount'].sum(), 2)
        net_position = round(total_receivables + total_payables, 2)
        krar_today_count = len(krar.get_customers_with_last_krar_today())
        krar_past_count = len(krar.get_customers_with_last_krar_past())

        kpis = [
            ("Receivables", f"₹{total_receivables:,.0f}", Colors.SUCCESS), # Simplified format
            ("Payables", f"₹{abs(total_payables):,.0f}", Colors.ERROR),
            ("Net Position", f"₹{net_position:,.0f}", Colors.FG_SHADE_1 if net_position >= 0 else Colors.REMINDER),
            ("Inventory Value", f"₹{self.inventory_total_value:,.0f}", Colors.ACTIVE_FOREGROUND),
            ("Krars Today", str(krar_today_count), Colors.ACTIVE_FOREGROUND),
            ("Krars Overdue", str(krar_past_count), Colors.REMINDER),
            ("Notes Today", str(self.today_notes_count), Colors.FG_SHADE_3),
        ]

        # Configure grid weights for KPIs dynamically
        num_kpis = len(kpis)
        for i in range(num_kpis):
            self.kpi_frame.grid_columnconfigure(i, weight=1, uniform="kpi_group") # Uniform makes columns equal width

        for i, (title, value, value_color) in enumerate(kpis):
            # Using a standard Frame for more background control if needed
            card = tk.Frame(self.kpi_frame, bg=Colors.BACKGROUND1, bd=1, relief=tk.SOLID)
            card.grid(row=0, column=i, sticky="nsew", padx=3, pady=3) # Reduced padding
            card.grid_rowconfigure(0, weight=1)
            card.grid_rowconfigure(1, weight=1)
            card.grid_columnconfigure(0, weight=1)

            # Use standard tk Labels if ttk style conflicts or for exact bg color
            tk.Label(card, text=title, font=("Consolas", 9), anchor='center',
                     bg=Colors.BACKGROUND1, fg=Colors.FOREGROUND).grid(row=0, column=0, sticky='ew', pady=(2,0))
            value_label = tk.Label(card, text=value, font=("Consolas", 16, "bold"), anchor='center',
                                  bg=Colors.BACKGROUND1, fg=value_color)
            value_label.grid(row=1, column=0, sticky='ew', pady=(0, 2))
            # For ttk:
            # ttk.Label(card, text=title, style='KPITitle.TLabel').grid(row=0, column=0, sticky='ew')
            # value_label = ttk.Label(card, text=value, style='KPI.TLabel', foreground=value_color)
            # value_label.grid(row=1, column=0, sticky='ew', pady=(0, 5))

    def create_financial_graphs(self):
        """Creates the financial graph section (bottom left)."""
        # Keep the 2x2 grid structure
        self.financial_frame.grid_rowconfigure(0, weight=1)
        self.financial_frame.grid_rowconfigure(1, weight=1)
        self.financial_frame.grid_columnconfigure(0, weight=1)
        self.financial_frame.grid_columnconfigure(1, weight=1)

        card1 = create_card_frame(self.financial_frame, text="Account Status (Count)")
        card1.grid(row=0, column=0, sticky="nsew", padx=(0,2), pady=(0,2))
        self.plot_account_count_pie(card1)

        card2 = create_card_frame(self.financial_frame, text="Financial Position (Amount)")
        card2.grid(row=0, column=1, sticky="nsew", padx=(2,0), pady=(0,2))
        self.plot_financial_position_pie(card2)

        card3 = create_card_frame(self.financial_frame, text="Receivables Overview (Amount vs Days)")
        card3.grid(row=1, column=0, columnspan=2, sticky="nsew", padx=(0,0), pady=(2,0))
        self.plot_receivables_scatter(card3)

    # --- Plotting functions (plot_account_count_pie, plot_financial_position_pie, plot_receivables_scatter) remain the same ---
    # (Keep implementations from the previous step)
    def plot_account_count_pie(self, parent_frame):
        """Plots the pie chart for Dr/Cr account counts."""
        count_dr = self.all_positive_df.shape[0]
        count_cr = self.all_negative_df.shape[0]
        total_accounts = count_dr + count_cr

        labels = [f'Receivable ({count_dr})', f'Payable ({count_cr})']
        sizes = [count_dr, count_cr]
        plot_colors = [self.Colors.SUCCESS, self.Colors.ERROR] # Green for Dr, Red for Cr
        explode = (0.05, 0) if count_dr > 0 else (0, 0) # Explode only if > 0

        if not any(sizes): # Avoid plotting if no data
            ttk.Label(parent_frame, text="No Account Data", style='KPITitle.TLabel').pack(expand=True)
            return

        fig = Figure(figsize=(4, 3), dpi=75, facecolor=self.Colors.BACKGROUND1) # Use card background
        ax = fig.add_subplot(111)
        ax.set_facecolor(self.Colors.BACKGROUND1)

        wedges, texts, autotexts = ax.pie(sizes, explode=explode, labels=labels, colors=plot_colors,
                                          autopct='%1.1f%%', shadow=False, startangle=90,
                                          textprops={'color': self.Colors.FOREGROUND, 'fontsize': 9})
        for autotext in autotexts:
            autotext.set_color(self.Colors.BACKGROUND) # White text on wedges
            autotext.set_fontweight('bold')

        ax.axis('equal')
        fig.tight_layout(pad=0.5)
        canvas = FigureCanvasTkAgg(fig, master=parent_frame)
        canvas.draw()
        canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

    def plot_financial_position_pie(self, parent_frame):
        """Plots the pie chart for Dr/Cr total amounts."""
        total_dr = self.all_positive_df['Amount'].sum()
        total_cr = abs(self.all_negative_df['Amount'].sum()) # Use absolute value for size

        labels = [f'Receivables\n(₹{total_dr:,.0f})', f'Payables\n(₹{total_cr:,.0f})']
        sizes = [total_dr, total_cr]
        plot_colors = [self.Colors.SUCCESS, self.Colors.ERROR]
        explode = (0.05, 0) if total_dr > 0 else (0, 0)

        if not any(s > 0 for s in sizes): # Check if any size is positive
            ttk.Label(parent_frame, text="No Financial Data", style='KPITitle.TLabel').pack(expand=True)
            return

        fig = Figure(figsize=(4, 3), dpi=75, facecolor=self.Colors.BACKGROUND1)
        ax = fig.add_subplot(111)
        ax.set_facecolor(self.Colors.BACKGROUND1)

        wedges, texts, autotexts = ax.pie(sizes, explode=explode, labels=labels, colors=plot_colors,
                                          autopct='%1.1f%%', shadow=False, startangle=90,
                                          textprops={'color': self.Colors.FOREGROUND, 'fontsize': 9})
        for autotext in autotexts:
             autotext.set_color(self.Colors.BACKGROUND)
             autotext.set_fontweight('bold')

        ax.axis('equal')
        fig.tight_layout(pad=0.5)
        canvas = FigureCanvasTkAgg(fig, master=parent_frame)
        canvas.draw()
        canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

    def plot_receivables_scatter(self, parent_frame):
        """Plots the scatter plot for positive balance accounts (Amount vs Days)."""
        df = self.all_positive_df

        if df.empty:
            ttk.Label(parent_frame, text="No Receivables Data", style='KPITitle.TLabel').pack(expand=True)
            return

        fig = Figure(figsize=(6, 3.5), dpi=75, facecolor=self.Colors.BACKGROUND1)
        ax = fig.add_subplot(111)
        ax.set_facecolor(self.Colors.BACKGROUND1)

        amounts = df['Amount']
        days = df['Days']

        ax.scatter(amounts, days, alpha=0.6, edgecolors='w', s=50, color=self.Colors.ACTIVE_FOREGROUND)

        ax.set_xlabel("Amount (₹)", color=self.Colors.FOREGROUND, fontsize=9)
        ax.set_ylabel("Days Outstanding", color=self.Colors.FOREGROUND, fontsize=9)

        ax.tick_params(axis='x', colors=self.Colors.FOREGROUND, labelsize=8)
        ax.tick_params(axis='y', colors=self.Colors.FOREGROUND, labelsize=8)
        ax.grid(True, linestyle='--', alpha=0.3, color=self.Colors.FG_SHADE_3)
        for spine in ax.spines.values():
            spine.set_edgecolor(self.Colors.FG_SHADE_3)

        fig.tight_layout(pad=1.0) # Add padding
        canvas = FigureCanvasTkAgg(fig, master=parent_frame)
        canvas.draw()
        canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
    # --- End of plotting functions ---


    def create_activity_section(self):
        """Creates Krar, Inventory, and Crop sections."""
        # Configure grid layout for activity frame
        self.activity_frame.grid_rowconfigure(0, weight=1) # Krar takes top part
        self.activity_frame.grid_rowconfigure(1, weight=1) # Inventory/Crop takes bottom part
        self.activity_frame.grid_columnconfigure(0, weight=1)

        # Krar Status Card with Tabs
        krar_card = create_card_frame(self.activity_frame, text="Krar Status")
        krar_card.grid(row=0, column=0, sticky="nsew", padx=0, pady=(0, 2)) # Grid placement

        notebook = ttk.Notebook(krar_card, style='TNotebook')
        today_frame = tk.Frame(notebook, bg=self.Colors.BACKGROUND2)
        past_frame = tk.Frame(notebook, bg=self.Colors.BACKGROUND2)
        future_frame = tk.Frame(notebook, bg=self.Colors.BACKGROUND2)
        notebook.add(today_frame, text=f"Today ({len(krar.get_customers_with_last_krar_today())})")
        notebook.add(past_frame, text=f"Overdue ({len(krar.get_customers_with_last_krar_past())})")
        notebook.add(future_frame, text=f"Upcoming ({len(krar.get_customers_with_last_krar_future())})")
        notebook.pack(fill=tk.BOTH, expand=True, padx=5, pady=(0,5)) # Padding inside card

        # Populate Krar tabs
        self.show_krar_table(today_frame, krar.get_customers_with_last_krar_today())
        self.show_krar_table(past_frame, krar.get_customers_with_last_krar_past())
        self.show_krar_table(future_frame, krar.get_customers_with_last_krar_future())

        # --- Inventory & Crop Section (using another Notebook) ---
        inv_crop_card = create_card_frame(self.activity_frame, text="Stock Overview")
        inv_crop_card.grid(row=1, column=0, sticky="nsew", padx=0, pady=(2, 0)) # Grid placement

        inv_notebook = ttk.Notebook(inv_crop_card, style='TNotebook')

        # Low Stock Tab
        low_stock_frame = tk.Frame(inv_notebook, bg=self.Colors.BACKGROUND2)
        inv_notebook.add(low_stock_frame, text=f"Low Stock ({len(self.low_stock_data)})")
        self.show_low_stock_list(low_stock_frame, self.low_stock_data)

        # Crop Summary Tab
        crop_summary_frame = tk.Frame(inv_notebook, bg=self.Colors.BACKGROUND2)
        inv_notebook.add(crop_summary_frame, text=f"Crop Stock ({len(self.crop_summary_data)})")
        self.show_crop_summary_list(crop_summary_frame, self.crop_summary_data)

        inv_notebook.pack(fill=tk.BOTH, expand=True, padx=5, pady=(0,5)) # Padding inside card

    # show_krar_table remains mostly the same, adjust style if needed
    def show_krar_table(self, parent_frame, customer_id_list):
        table_data = self.get_krar_customer_data(customer_id_list)
        column_names = ["ID", "Name"] # Simplified Krar list

        if not table_data:
            tk.Label(parent_frame, text="No Krars.", # Use tk for specific bg
                     bg=self.Colors.BACKGROUND2, fg=self.Colors.FOREGROUND).pack(pady=10)
            return

        tree = ttk.Treeview(parent_frame, columns=column_names, show='headings', height=4, style="List.Treeview") # Apply List style

        tree.column('#0', width=0, stretch='no')
        tree.column("ID", width=40, anchor='e') # Align ID right
        tree.column("Name", width=150, anchor='w')

        for col_name in column_names:
            tree.heading(col_name, text=col_name, anchor='w')

        for i, row in enumerate(table_data):
            tag = 'even_krar' if i % 2 == 0 else 'odd_krar'
            tree.insert('', 'end', values=(row[0], row[1]), tags=(tag,)) # Only ID and Name

        tree.tag_configure('odd_krar', background=self.Colors.BACKGROUND2, foreground=self.Colors.FOREGROUND)
        tree.tag_configure('even_krar', background=self.Colors.BACKGROUND3, foreground=self.Colors.FOREGROUND)

        scrollbar = ttk.Scrollbar(parent_frame, orient=tk.VERTICAL, command=tree.yview)
        tree.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y, padx=(0,2), pady=2)
        tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(2,0), pady=2)
        tree.bind("<Double-1>", self.on_double_click_krar_to_account)

    def get_krar_customer_data(self, customer_id_list):
        # (Keep implementation from the previous step)
        customer_details_list = []
        for cust_id in customer_id_list:
            details = accounts.get_customer_details(cust_id)
            if details:
                customer_details_list.append(details) # (id, name, details)
        return customer_details_list

    def on_double_click_krar_to_account(self, event):
        # (Keep implementation from the previous step)
        tree = event.widget
        region = tree.identify("region", event.x, event.y)
        if region == "cell":
            item_iid = tree.identify_row(event.y)
            if not item_iid: return
            row_data = tree.item(item_iid)['values']
            if not row_data: return

            try:
                customer_id = row_data[0]
                customer_name = row_data[1]
                detail_table_name = f"{customer_id} {customer_name}"

                if hasattr(self.master, 'master') and hasattr(self.master.master, 'reportframe'):
                    reports_page = self.master.master.reportframe
                    reports_page.db_var.set("accounts.db")
                    reports_page.handle_db_selection()

                    if detail_table_name in reports_page.table_dropdown.cget('values'):
                        reports_page.table_var.set(detail_table_name)
                        reports_page.show_table()
                        if hasattr(self.master.master, 'report_frame_label'):
                             self.master.master.report_frame_label.on_click(None)
                        else: print("Could not find report_frame_label.")
                    else:
                        print(f"Target table '{detail_table_name}' not found.")
                        if hasattr(self.master.master, 'report_frame_label'):
                             self.master.master.report_frame_label.on_click(None)
                else: print("Error: Cannot access ReportsPage instance.")
            except Exception as e: print(f"Error processing Krar double click: {e}")


    def show_low_stock_list(self, parent_frame, low_stock_data):
        """Displays a list of low stock items."""
        column_names = ["ID", "Name", "Qty"]
        if not low_stock_data:
            tk.Label(parent_frame, text="No low stock items.",
                     bg=self.Colors.BACKGROUND2, fg=self.Colors.FOREGROUND).pack(pady=10)
            return

        tree = ttk.Treeview(parent_frame, columns=column_names, show='headings', height=4, style="List.Treeview")

        tree.column('#0', width=0, stretch='no')
        tree.column("ID", width=40, anchor='e')
        tree.column("Name", width=150, anchor='w')
        tree.column("Qty", width=50, anchor='e')

        for col_name in column_names:
            tree.heading(col_name, text=col_name, anchor='w')

        for i, (item_id, name, qty) in enumerate(low_stock_data):
             tag = 'even_low' if i % 2 == 0 else 'odd_low'
             # Add visual cue for very low stock
             if qty <= 2: tag = 'critical_low'
             tree.insert('', 'end', values=(item_id, name, qty), tags=(tag,))

        tree.tag_configure('odd_low', background=self.Colors.BACKGROUND2, foreground=self.Colors.FOREGROUND)
        tree.tag_configure('even_low', background=self.Colors.BACKGROUND3, foreground=self.Colors.FOREGROUND)
        tree.tag_configure('critical_low', background=self.Colors.DELETE, foreground="#FFFFFF") # Highlight critical

        scrollbar = ttk.Scrollbar(parent_frame, orient=tk.VERTICAL, command=tree.yview)
        tree.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y, padx=(0,2), pady=2)
        tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(2,0), pady=2)
        # Optional: Bind double-click to go to inventory report page
        # tree.bind("<Double-1>", self.on_double_click_inventory)

    def show_crop_summary_list(self, parent_frame, crop_data):
         """Displays a summary of crop stock."""
         # crop_data format: [Crop, Unit, Quantity, Avg Cost, Total Value]
         column_names = ["Crop", "Qty", "Value"] # Simplified view

         if not crop_data:
             tk.Label(parent_frame, text="No crop stock data.",
                      bg=self.Colors.BACKGROUND2, fg=self.Colors.FOREGROUND).pack(pady=10)
             return

         tree = ttk.Treeview(parent_frame, columns=column_names, show='headings', height=4, style="List.Treeview")

         tree.column('#0', width=0, stretch='no')
         tree.column("Crop", width=120, anchor='w')
         tree.column("Qty", width=60, anchor='e')
         tree.column("Value", width=80, anchor='e')

         for col_name in column_names:
             tree.heading(col_name, text=col_name, anchor='w')

         for i, row in enumerate(crop_data):
             tag = 'even_crop' if i % 2 == 0 else 'odd_crop'
             try:
                 # Extract relevant data: Name (row[0]), Qty (row[2]), Total Value (row[4])
                 qty_str = f"{row[2]:.2f}" if isinstance(row[2], (float, int)) else str(row[2])
                 val_str = f"₹{row[4]:,.0f}" if isinstance(row[4], (float, int)) else str(row[4])
                 tree.insert('', 'end', values=(row[0], qty_str, val_str), tags=(tag,))
             except (IndexError, TypeError, ValueError) as e:
                  print(f"Error processing crop row: {row}, Error: {e}")
                  tree.insert('', 'end', values=(row[0] if row else 'ERR', 'ERR', 'ERR'), tags=(tag,))


         tree.tag_configure('odd_crop', background=self.Colors.BACKGROUND2, foreground=self.Colors.FOREGROUND)
         tree.tag_configure('even_crop', background=self.Colors.BACKGROUND3, foreground=self.Colors.FOREGROUND)

         scrollbar = ttk.Scrollbar(parent_frame, orient=tk.VERTICAL, command=tree.yview)
         tree.configure(yscrollcommand=scrollbar.set)
         scrollbar.pack(side=tk.RIGHT, fill=tk.Y, padx=(0,2), pady=2)
         tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(2,0), pady=2)
         # Optional: Bind double-click to go to crop report page
         # tree.bind("<Double-1>", self.on_double_click_crop)


    def redraw_graphs(self):
        """Redraws graphs and lists, useful for theme changes."""
        # KPIs are Labels, update their config directly or rely on ttk style
        for card in self.kpi_frame.winfo_children():
             if isinstance(card, tk.Frame): # Assuming tk Frame for KPIs
                for widget in card.winfo_children():
                    if isinstance(widget, tk.Label):
                         # Update colors based on current theme stored in self.Colors
                         if 'bold' in widget.cget('font'): # Value label
                             # Keep specific value color logic if needed, else use default
                             # For simplicity, just updating bg/fg here. Needs refinement
                             # if title requires specific color.
                             widget.config(bg=self.Colors.BACKGROUND1) # Reapply bg
                             # Keep value_color logic here if it's dynamic
                             # widget.config(fg=value_color)
                         else: # Title label
                             widget.config(bg=self.Colors.BACKGROUND1, fg=self.Colors.FOREGROUND)

        # Check if data exists before trying to redraw graphs/lists
        if not self.accounts_df.empty:
            self._clear_frame(self.financial_frame)
            self._clear_frame(self.activity_frame) # Clear activity too

            # Re-create graph sections
            self.create_financial_graphs()
            # Re-create activity section (Krar, Low Stock, Crop)
            self.create_activity_section()
        else:
            # If no data, ensure loading or error message is shown correctly
            self._clear_frame(self.kpi_frame) # Clear potentially stale KPIs too
            self._clear_frame(self.financial_frame)
            self._clear_frame(self.activity_frame)
            if not self.loading_label.winfo_ismapped(): # Check if loading label is active
                 error_label = ttk.Label(self, text="No Data Loaded",
                                       font="Consolas 20", background=Colors.BACKGROUND,
                                       foreground=Colors.ERROR, anchor='center')
                 error_label.place(relx=0.5, rely=0.5, anchor='center')


# --- Main execution for testing (keep as is or update mock data) ---
if __name__ == "__main__":
    # (Keep the mock data setup and app execution from the previous step)
    # Mock data function for testing without full DB access
    def get_mock_all_list():
        data = {
            'customer_id': [1, 2, 3, 4, 5, 6],
            'name': ['Alice', 'Bob', 'Charlie', 'David', 'Eve', 'Frank'],
            'detail': ['Detail A', 'Detail B', 'Detail C', 'Detail D', 'Detail E', 'Detail F'],
            'Amount': [1500.50, -500.75, 25000.00, 800.00, -1200.00, 0.0],
            'Days': [30, 65, 15, 90, 45, 120]
        }
        df = pd.DataFrame(data)
        df['account_score'] = np.random.rand(len(df))
        return df

    # Replace real function with mock for testing
    import mypandasfile
    mypandasfile.get_all_list = get_mock_all_list
    # Mock other DB functions
    inventory.get_total_inventory_value = lambda: 123456.78
    inventory.get_low_stock_items = lambda threshold=10: [(101,'Low Item 1', 3), (102,'Low Item 2', 9)]
    inventory.get_item_quantity = lambda item_id: 5 # Mock quantity
    crop_database.get_stock_summary = lambda: [('WHEAT','KG', 500.5, 25.50, 12762.75), ('CORN','KG', 1200, 18.00, 21600.00)]
    daily_db.get_todays_notes_summary = lambda: 7
    krar.get_customers_with_last_krar_today = lambda: [1, 3]
    krar.get_customers_with_last_krar_past = lambda: [2]
    krar.get_customers_with_last_krar_future = lambda: [4, 5]
    accounts.get_customer_details = lambda cid: (cid, f'Mock Name {cid}', f'Mock Details {cid}')


    app = tk.Tk()
    app.title("Dashboard Enhanced Test")
    app.geometry("1200x750")

    # Mock main app structure
    class MockReportPage: pass
    class MockModifyPage: pass
    class MockApp:
        reportframe = MockReportPage()
        modifyframe = MockModifyPage()
        def set_status(self, msg): print(f"Status: {msg}")
        def report_frame_label(self): pass
        def my_parallel_processes(self): # Mock the refresh trigger target
             print("MockApp: my_parallel_processes called")
             # Simulate data loading and calling back to homepage
             mock_data_new = get_mock_all_list() # Get fresh mock data
             homepage.all_graphs_function(mock_data_new)

    mock_app_instance = MockApp()

    # --- Apply Theme ---
    style = ttk.Style(app)
    style.theme_use('clam')
    # (Keep style configurations from previous step)
    style.configure("Treeview", background=Colors.BACKGROUND, foreground=Colors.FOREGROUND, fieldbackground=Colors.BACKGROUND, rowheight=25, font=('Consolas', 10))
    style.configure("Treeview.Heading", background=Colors.BACKGROUND1, foreground=Colors.FG_SHADE_3, font=('Consolas', 11, 'bold'), relief="flat")
    style.map("Treeview.Heading", relief=[('active','groove'),('pressed','sunken')])
    style.configure("TNotebook", background=Colors.BACKGROUND, borderwidth=0)
    style.configure("TNotebook.Tab", background=Colors.BACKGROUND1, foreground=Colors.FOREGROUND, padding=[5, 2], font=('Consolas', 10))
    style.map("TNotebook.Tab", background=[("selected", Colors.ACTIVE_BACKGROUND)], foreground=[("selected", Colors.FG_SHADE_1)])
    style.configure('Card.TLabelframe', background=Colors.BACKGROUND1, borderwidth=1, relief=tk.GROOVE)
    style.configure('Card.TLabelframe.Label', background=Colors.BACKGROUND1, foreground=Colors.ACTIVE_FOREGROUND, font=("Consolas", 12, "bold"))
    style.configure('List.Treeview', background=Colors.BACKGROUND2, fieldbackground=Colors.BACKGROUND2, foreground=Colors.FOREGROUND, font=('Consolas', 9))
    style.configure('List.Treeview.Heading', background=Colors.BG_SHADE_1, foreground=Colors.ACTIVE_FOREGROUND, font='Consolas 9 bold')
    style.configure("Refresh.TButton", font=("Consolas", 10), padding=5)
    style.map("Refresh.TButton", background=[('active', Colors.LIGHT_BG), ('!active', Colors.BACKGROUND1)], foreground=[('active', Colors.ACTIVE_FOREGROUND)])


    homepage = HomePage(app)
    homepage.pack(fill=tk.BOTH, expand=True)
    homepage.master.master = mock_app_instance # Assign mock app

    # Simulate data loading
    mock_data = get_mock_all_list()
    app.after(500, lambda: homepage.all_graphs_function(mock_data)) # Load after slight delay

    app.mainloop()
 
import tkinter as tk

from .mytheme import Colors
from tkinter import ttk

from database import accounts, database, krar

# import accounts
# import inventory
# import database
# import krar
# import datetime
# import time

# import mypandasfile
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure
import matplotlib.pyplot as plt




class HomePage(tk.Frame):

    def __init__(self, master, **kwargs):
        super().__init__(master, **kwargs)
        self.Colors = Colors
        self.one = 0

        # img = tk.PhotoImage(file="myicons\\framebg2.png")

        # self.background_title = tk.Label(self, image=img)
        # self.background_title.place(relx=0, rely=0, relheight=1, relwidth=1)

        # self.img = img

        self.karar_data_frame = KrarData(self)
        # self.karar_data_frame.place(relx=0.78, rely=0.01, relheight=0.98, relwidth=0.21)
        self.karar_data_frame.pack(expand=1, fill='both')
    

    def all_graphs_function(self, accounts_df):
        for widget in self.winfo_children():
            widget.destroy()
        
        # self.background_title = tk.Label(self, image=self.img)
        # self.background_title.place(relx=0, rely=0, relheight=1, relwidth=1)
        self.one = 1
        self.karar_data_frame = KrarData(self)
        self.karar_data_frame.place(relx=0.78, rely=0.01, relheight=0.98, relwidth=0.21)

        self.all_positive_df = accounts_df.loc[accounts_df['Amount'] >=0]
        self.all_negative_df = accounts_df.loc[accounts_df['Amount'] <0]

        self.sales_data_frame = SalesData(self)
        self.sales_data_frame.place(relx=0.01, rely=0.01, relheight=0.485, relwidth=0.4)
        self.recieve_data_frame = RecieceData(self)
        self.recieve_data_frame.place(relx=0.42, rely=0.01, relheight=0.485, relwidth=0.35)
        self.items_data_frame = ItemsData(self)
        self.items_data_frame.place(relx=0.01, rely=0.505, relheight=0.485, relwidth=0.35)
        self.account_data_frame = AccountsData(self)
        self.account_data_frame.place(relx=0.37, rely=0.505, relheight=0.485, relwidth=0.4)
        
    def redraw_graphs(self):
        for widget in self.winfo_children():
            widget.destroy()
        
        # self.background_title = tk.Label(self, image=self.img)
        # self.background_title.place(relx=0, rely=0, relheight=1, relwidth=1)
        self.karar_data_frame = KrarData(self)
        self.karar_data_frame.place(relx=0.78, rely=0.01, relheight=0.98, relwidth=0.21)
        self.sales_data_frame = SalesData(self)
        self.sales_data_frame.place(relx=0.01, rely=0.01, relheight=0.485, relwidth=0.4)
        self.recieve_data_frame = RecieceData(self)
        self.recieve_data_frame.place(relx=0.42, rely=0.01, relheight=0.485, relwidth=0.35)
        self.items_data_frame = ItemsData(self)
        self.items_data_frame.place(relx=0.01, rely=0.505, relheight=0.485, relwidth=0.35)
        self.account_data_frame = AccountsData(self)
        self.account_data_frame.place(relx=0.37, rely=0.505, relheight=0.485, relwidth=0.4)


class SalesData(tk.Frame):
    def __init__(self, master, **kwargs):
        super().__init__(master, **kwargs)
        self.Colors = self.master.Colors
        self.config(background=self.Colors.BACKGROUND)
        self.debit_credit_bar_graph()
        

    def debit_credit_bar_graph(self):
        data = database.last_7_day_report()
        names = [item[0] for item in data]
        values = [item[1] for item in data]

        fig = Figure(figsize=(5, 3), dpi=100, facecolor=self.Colors.BACKGROUND)

        ax = fig.add_subplot(111)
        ax.set_facecolor(self.Colors.BACKGROUND)

        markerline, stemline, baseline = ax.stem(names, values, linefmt='-', markerfmt='o', basefmt=' ')

        plt.setp(markerline, color=self.Colors.ACTIVE_FOREGROUND)
        plt.setp(stemline, color=self.Colors.ACTIVE_FOREGROUND)
        plt.setp(baseline, visible=False)

        # ax.set_title(total_diffrence_value)

        fig.tight_layout()

        canvas = FigureCanvasTkAgg(fig, master=self)
        canvas.draw()
        canvas.get_tk_widget().pack()

class RecieceData(tk.Frame):
    def __init__(self, master, **kwargs):
        super().__init__(master, **kwargs)
        self.Colors = self.master.Colors
        self.config(background=self.Colors.BACKGROUND)
        self.total_pie_graph()

    def total_pie_graph(self):
        # values
        total_debit_value = self.master.all_positive_df.shape[0]
        total_credit_value = self.master.all_negative_df.shape[0]
        total_sum_value = total_debit_value+total_credit_value
        # print(total_debit_value)

        fig = Figure(figsize=(5,4), dpi=100, facecolor=self.Colors.BACKGROUND)
        ax = fig.add_subplot(111)
        ax.set_facecolor(self.Colors.BACKGROUND)


        categories = ['Dr', 'Cr']
        amounts = [total_debit_value, total_credit_value]
        mycolors = [self.Colors.FG_SHADE_1, self.Colors.FG_SHADE_3]
        ax.pie(amounts, labels=categories, colors=mycolors, autopct='%1.1f%%')
        ax.set_title(total_sum_value)

        fig.tight_layout()
        canvas = FigureCanvasTkAgg(fig, master=self)
        canvas.draw()
        canvas.get_tk_widget().pack()

class AccountsData(tk.Frame):
    def __init__(self, master, **kwargs):
        super().__init__(master, **kwargs)
        self.Colors = self.master.Colors
        self.config(background=self.Colors.BACKGROUND)
        self.positive_scater_plot()

    def positive_scater_plot(self):
        # values
        df = self.master.all_positive_df
        
        fig = Figure(figsize=(5,4), dpi=100, facecolor=self.Colors.BACKGROUND)
        ax = fig.add_subplot(111)
        ax.set_facecolor(self.Colors.BACKGROUND)


        ax.scatter(df['Amount'], df['Days'])

        # ax.set_xlabel("Amount")
        # ax.set_ylabel("Days")
        # ax.set_title(total_diffrence_value)

        fig.tight_layout()

        canvas = FigureCanvasTkAgg(fig, master=self)
        canvas.draw()
        canvas.get_tk_widget().pack()

class ItemsData(tk.Frame):
    def __init__(self, master, **kwargs):
        super().__init__(master, **kwargs)
        self.Colors = self.master.Colors
        self.config(background=self.Colors.BACKGROUND)
        self.total_pie_graph()

    def total_pie_graph(self):
        # values
        total_debit_value = self.master.all_positive_df['Amount'].sum()
        total_credit_value = self.master.all_negative_df['Amount'].sum()*(-1)
        total_sum_value = round(total_debit_value-total_credit_value, 2)

        fig = Figure(figsize=(5,4), dpi=100, facecolor=self.Colors.BACKGROUND)
        ax = fig.add_subplot(111)
        ax.set_facecolor(self.Colors.BACKGROUND)


        categories = ['Dr', 'Cr']
        amounts = [total_debit_value, total_credit_value]
        mycolors = [self.Colors.FG_SHADE_1, self.Colors.FG_SHADE_3]
        ax.pie(amounts, labels=categories, colors=mycolors, autopct='%1.1f%%')
        ax.set_title(total_sum_value)

        fig.tight_layout()
        canvas = FigureCanvasTkAgg(fig, master=self)
        canvas.draw()
        canvas.get_tk_widget().pack()



class KrarData(tk.Frame):
    def __init__(self, master, **kwargs):
        super().__init__(master, **kwargs)
        
        self.Colors = self.master.Colors
        self.config(background=self.Colors.BACKGROUND)

        if self.master.one == 1:

            self.todo_title = tk.Label(self, text='Today', font="Consolas 16", bg=self.Colors.BACKGROUND, fg=self.Colors.FG_SHADE_3, anchor='center')
            self.todo_title.pack(fill='x')

            self.table_frame = tk.Frame(self, bg=self.Colors.BACKGROUND)
            self.table_frame.pack(fill="x", expand=1)
            self.show_table(self.table_frame,krar.get_customers_with_last_krar_today())

            self.todo_title2 = tk.Label(self, text='Past', font="Consolas 14", bg=self.Colors.BACKGROUND, fg=self.Colors.FG_SHADE_3, anchor='center')
            self.todo_title2.pack(fill='x')

            self.table_frame2 = tk.Frame(self, bg=self.Colors.BACKGROUND)
            self.table_frame2.pack(fill="x", expand=1)
            self.show_table(self.table_frame2,krar.get_customers_with_last_krar_past())

            self.todo_title3 = tk.Label(self, text='Upcoming', font="Consolas 14", bg=self.Colors.BACKGROUND, fg=self.Colors.FG_SHADE_3, anchor='center')
            self.todo_title3.pack(fill='x')

            self.table_frame3 = tk.Frame(self, bg=self.Colors.BACKGROUND)
            self.table_frame3.pack(fill="x", expand=1)
            self.show_table(self.table_frame3,krar.get_customers_with_last_krar_future())

        else:
            self.todo_title = tk.Label(self, text='Today', font="Consolas 16", bg=self.Colors.BACKGROUND, fg=self.Colors.FG_SHADE_3, anchor='center')
            self.todo_title.place(relx=0, rely=0, relwidth=.3, relheight=0.06)

            self.table_frame = tk.Frame(self, bg=self.Colors.BACKGROUND)
            self.table_frame.place(relx=0, rely=0.06, relwidth=.35, relheight=0.94)
            self.show_table(self.table_frame,krar.get_customers_with_last_krar_today())

            self.todo_title2 = tk.Label(self, text='Past', font="Consolas 14", bg=self.Colors.BACKGROUND, fg=self.Colors.FG_SHADE_3, anchor='center')
            self.todo_title2.place(relx=0.4, rely=0, relwidth=.3, relheight=0.06)

            self.table_frame2 = tk.Frame(self, bg=self.Colors.BACKGROUND)
            self.table_frame2.place(relx=0.35, rely=0.06, relwidth=.35, relheight=0.94)
            self.show_table(self.table_frame2,krar.get_customers_with_last_krar_past())

            self.todo_title3 = tk.Label(self, text='Upcoming', font="Consolas 14", bg=self.Colors.BACKGROUND, fg=self.Colors.FG_SHADE_3, anchor='center')
            self.todo_title3.place(relx=0.7, rely=0, relwidth=.3, relheight=0.06)

            self.table_frame3 = tk.Frame(self, bg=self.Colors.BACKGROUND)
            self.table_frame3.place(relx=0.7, rely=0.06, relwidth=.3, relheight=0.94)
            self.show_table(self.table_frame3,krar.get_customers_with_last_krar_future())
        

    def set_undue_krar(self):
        customer_name = self.table_dropdown.get()
        if customer_name:
            krar.update_krar_tag_by_name(customer_name, 0)

    def show_data(self, accounts_id_list):
        # unsettled_accounts = krar.get_accounts_with_unsettled_krars()
        table_data = []

        for idx, account_id in enumerate(accounts_id_list):
            customer_details = accounts.get_customer_details(account_id)

            customer_name = f"{customer_details[0]} {customer_details[1]}"
            temp = []
            temp.append(customer_details[2])
            temp.extend(krar.get_unsettled_krar_dates(account_id))
            table_data.append([customer_name, temp])
        
        return table_data
        
    def show_table(self, root, x):
        table_data = self.show_data(x)
        column_name = ["Name",]
        # print(table_data)
        
        if column_name and table_data:
            for widget in root.winfo_children():
                widget.destroy()
                
            tree = ttk.Treeview(root, columns=column_name, show='tree')
            # tree['columns'] = column_name
            tree.heading("#0", text="")
            tree.column('#0', width=30, stretch="no")

            c = 0
            for i in table_data:
                c += 1
                tg = 'odd'
                if c%2 == 0:
                    tg = "even"
                tree.insert('', 'end', iid=c, text="", values=i, tags = tg )
                for j in i[1]:
                    tree.insert(c, 'end', text=c, values=[j,0], tags = tg )


            tree.tag_configure('odd', background=self.Colors.ACTIVE_BACKGROUND)
            tree.tag_configure('even', background=self.Colors.ACTIVE_FOREGROUND)
            tree.pack(fill="both", expand=True)




if __name__ == "__main__":
    app = tk.Tk()
    app.state("zoomed")
    h = HomePage(app)
    h.pack(expand=1, fill="both")
    app.mainloop()

 
import tkinter as tk
# from tkinter import ttk
from datetime import datetime

from .mytheme import Colors

from database import inventory, database
# import accounts
# import inventory
# import database
# from inventory import
# from sales import Sales

class AddItemsPage(tk.Frame):
    def __init__(self, master, **kwargs):
        super().__init__(master, **kwargs)

        APP_FONT = "Consolas 12"
        APP_FONT1 = "Consolas 14"

        # img = tk.PhotoImage(file="myicons\\framebg2.png")

        # self.background_title = tk.Label(self, image=img)
        # self.background_title.place(relx=0, rely=0, relheight=1, relwidth=1)

        # self.img = img


        # main frame to include all frames
        self.main_frame = tk.Frame(self, bg=Colors.BACKGROUND)
        self.main_frame.place(relx=0.2, rely=0.01, relwidth=.6, relheight=.98)


        # self.background_title = tk.Label(self.main_frame, image=img)
        # self.background_title.place(relx=0, rely=0, relheight=1, relwidth=1)


        # title frame
        title_frame = tk.Frame(self.main_frame, bg=Colors.BACKGROUND1)
        title_frame.pack(fill='x', pady=2, padx=10)
        title_name_label = tk.Label(title_frame, text="Items", font="Consolas 18", bg=Colors.BACKGROUND1, fg=Colors.FG_SHADE_3, anchor='center')
        title_name_label.pack(padx=40, fill='x')

        # GROUP 1
        frame1 = tk.Frame(self.main_frame, bg=Colors.BACKGROUND)
        frame1.pack(fill='x', pady=(10,0), padx=10)
        # Name Entry Box
        name_frame = tk.Frame(frame1, bg=Colors.BACKGROUND)
        name_frame.pack(fill='x', side='left', expand=1)
        name_label = tk.Label(name_frame, text="Item Name: ", font=APP_FONT, bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND, anchor='w')
        name_label.pack(fill='x', padx=(40, 10), pady=(10,0))
        self.name_entry = tk.Entry(name_frame, font=APP_FONT1, bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_1, relief='solid')
        self.name_entry.pack(fill='x', padx=(40, 10), pady=(0,10))
        # Other Details Entry Box
        details_frame = tk.Frame(frame1, bg=Colors.BACKGROUND)
        details_frame.pack(fill='x', side='left', expand=1)
        details_label = tk.Label(details_frame, text="Source: ", font=APP_FONT, bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND, anchor='w')
        details_label.pack(fill='x')
        self.details_entry = tk.Entry(details_frame, font=APP_FONT1, bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_1, relief='solid')
        self.details_entry.pack(fill='x', padx=(0,40))

        # GROUP 2
        frame2 = tk.Frame(self.main_frame, bg=Colors.BACKGROUND)
        frame2.pack(fill='x', pady=0, padx=10)
        # Date Entry Box
        date_frame = tk.Frame(frame2, bg=Colors.BACKGROUND)
        date_frame.pack(fill='x', side='left', expand=1)
        date_label = tk.Label(date_frame, text="Date: ", font=APP_FONT, bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND, anchor='w')
        date_label.pack(fill='x', padx=(40,10), pady=(10,0))
        self.date_entry = tk.Entry(date_frame, font=APP_FONT1, bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_1, relief='solid')
        self.date_entry.pack(fill='x', padx=(40,10), pady=(0,10))
        self.date_entry.insert(0, datetime.today().strftime('%Y-%m-%d'))
        # Opening Balance Entry Box
        balance_frame = tk.Frame(frame2, bg=Colors.BACKGROUND)
        balance_frame.pack(fill='x', side='left', expand=1)
        balance_label = tk.Label(balance_frame, text="Opening Balance: ", font=APP_FONT, bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND, anchor='w')
        balance_label.pack(fill='x')
        self.balance_entry = tk.Entry(balance_frame, font=APP_FONT1, bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_1, relief='solid')
        self.balance_entry.pack(padx=(0, 40), fill='x')

        # GROUP 3
        frame3 = tk.Frame(self.main_frame, bg=Colors.BACKGROUND)
        frame3.pack(fill='x', pady=0, padx=10)
        # stock value
        stock_value_frame = tk.Frame(frame3, bg=Colors.BACKGROUND)
        stock_value_frame.pack(fill='x', side='left', expand=1)
        stock_value_label = tk.Label(stock_value_frame, text="Stock Value: ", font=APP_FONT, bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND, anchor='w')
        stock_value_label.pack(fill='x', padx=(40, 10), pady=(10, 0))
        self.stock_value_entry = tk.Entry(stock_value_frame, font=APP_FONT1, bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_1, relief='solid')
        self.stock_value_entry.pack(fill='x', padx=(40, 10), pady=(0,10))
        # Last Value Entry Box
        last_value_frame = tk.Frame(frame3, bg=Colors.BACKGROUND)
        last_value_frame.pack(fill='x', side='left', expand=1)
        last_value_label = tk.Label(last_value_frame, text="Last Value: ", font=APP_FONT, bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND, anchor='w')
        last_value_label.pack(fill='x')
        self.last_value_entry = tk.Entry(last_value_frame, font=APP_FONT1, bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_1, relief='solid')
        self.last_value_entry.pack(padx=(0, 40), fill='x')

        # GROUP 4
        frame4 = tk.Frame(self.main_frame, bg=Colors.BACKGROUND)
        frame4.pack(fill='x', pady=0, padx=10)
        # pakka kacha
        pk_frame = tk.Frame(frame4, bg=Colors.BACKGROUND)
        pk_frame.pack(fill='x', side='left', expand=1)
        pk_label = tk.Label(pk_frame, text="Pakka Kacha: [P/K] ", font=APP_FONT, bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND, anchor='w')
        pk_label.pack(fill='x', padx=(40, 10), pady=(10, 0))
        self.pk_entry = tk.Entry(pk_frame, font=APP_FONT1, bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_1, relief='solid')
        self.pk_entry.pack(fill='x', padx=(40, 10), pady=(0,10))
        self.pk_entry.insert(0, 'P')
        # GST Value Entry Box
        gst_value_frame = tk.Frame(frame4, bg=Colors.BACKGROUND)
        gst_value_frame.pack(fill='x', side='left', expand=1)
        gst_value_label = tk.Label(gst_value_frame, text="GST Value: ", font=APP_FONT, bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND, anchor='w')
        gst_value_label.pack(fill='x')
        self.gst_value_entry = tk.Entry(gst_value_frame, font=APP_FONT1, bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_1, relief='solid')
        self.gst_value_entry.pack(padx=(0, 40), fill='x')

        # GROUP 5
        frame5 = tk.Frame(self.main_frame, bg=Colors.BACKGROUND)
        frame5.pack(fill='x', pady=0, padx=10)
        # pakka kacha
        batch_frame = tk.Frame(frame5, bg=Colors.BACKGROUND)
        batch_frame.pack(fill='x', side='left', expand=1)
        batch_label = tk.Label(batch_frame, text="Batch: ", font=APP_FONT, bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND, anchor='w')
        batch_label.pack(fill='x', padx=(40, 10), pady=(10, 0))
        self.batch_entry = tk.Entry(batch_frame, font=APP_FONT1, bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_1, relief='solid')
        self.batch_entry.pack(fill='x', padx=(40, 10), pady=(0,10))
        self.batch_entry.insert(0, 'NA')
        # GST Value Entry Box
        expiry_frame = tk.Frame(frame5, bg=Colors.BACKGROUND)
        expiry_frame.pack(fill='x', side='left', expand=1)
        expiry_label = tk.Label(expiry_frame, text="Expiry: ", font=APP_FONT, bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND, anchor='w')
        expiry_label.pack(fill='x')
        self.expiry_value_entry = tk.Entry(expiry_frame, font=APP_FONT1, bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_1, relief='solid')
        self.expiry_value_entry.pack(padx=(0, 40), fill='x')
        self.expiry_value_entry.insert(0, 'NA')

        # GROUP 6
        frame6 = tk.Frame(self.main_frame, bg=Colors.BACKGROUND)
        frame6.pack(fill='x', pady=0, padx=10)
        # pakka kacha
        unit_frame = tk.Frame(frame6, bg=Colors.BACKGROUND)
        unit_frame.pack(fill='x', side='left', expand=1)
        unit_label = tk.Label(unit_frame, text="Unit: ", font=APP_FONT, bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND, anchor='w')
        unit_label.pack(fill='x', padx=(40, 10), pady=(10, 0))
        self.unit_entry = tk.Entry(unit_frame, font=APP_FONT1, bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_1, relief='solid')
        self.unit_entry.pack(fill='x', padx=(40, 10), pady=(0,10))
        self.unit_entry.insert(0, 'PCS')
        # GST Value Entry Box
        type_value_frame = tk.Frame(frame6, bg=Colors.BACKGROUND)
        type_value_frame.pack(fill='x', side='left', expand=1)
        type_value_label = tk.Label(type_value_frame, text="Type: [F, P, S, O] ", font=APP_FONT, bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND, anchor='w')
        type_value_label.pack(fill='x')
        self.type_value_entry = tk.Entry(type_value_frame, font=APP_FONT1, bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_1, relief='solid')
        self.type_value_entry.pack(padx=(0, 40), fill='x')
        self.type_value_entry.insert(0, 'O')


        # Add Item Button
        button_frame = tk.Frame(self.main_frame, bg=Colors.BACKGROUND)
        button_frame.pack(fill='x', pady=(10,0), padx=10)
        self.add_button = tk.Button(button_frame, text="Add Item", font=APP_FONT, command=self.add_item, bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_3, relief='solid')
        self.add_button.pack(padx=40, fill='x', pady=(10, 10))


    def add_item(self):
        name = self.name_entry.get().upper()
        date = self.date_entry.get().upper()
        details = self.details_entry.get().upper()
        opening_balance = self.balance_entry.get()
        stock_value = self.stock_value_entry.get()
        last_value = self.last_value_entry.get()
        pk_value = self.pk_entry.get().upper()
        gst_value = self.gst_value_entry.get()
        batch_value = self.batch_entry.get().upper()
        expiry_date = self.expiry_value_entry.get()
        unit_value = self.unit_entry.get().upper()
        type_value = self.type_value_entry.get().upper()

        # verify entry
        if name and date and details and pk_value and batch_value and expiry_date and unit_value and type_value:
            item_id = inventory.add_new_item(name, stock_value,last_value, unit_value, batch_value, expiry_date, gst_value, type_value, pk_value)
            inventory.add_item_transaction(item_id,date, opening_balance, 0, details)

            dailynote = f"02 = {name}, {date}, {stock_value}, {details}, {opening_balance}, {last_value} , {unit_value}, {batch_value}, {expiry_date}, {gst_value}, {type_value}, {pk_value}"
            database.add_note_to_date(dailynote)

            if __name__ != "__main__":
                self.master.master.set_status(f"Item added: {item_id}")

        else:
            if __name__ == "__main__":
                print("Some fields are empty")
            else:
                self.master.master.set_status("[-]|Some fields are empty|")

        # add account to database
        # (code for this would depend on how you implemented your accounts database)


if __name__ == "__main__":
    app = tk.Tk()
    app.state("zoomed")
    a = AddItemsPage(app)
    a.pack(expand=1, fill="both")
    app.mainloop()

 
import tkinter as tk
# import sqlite3

# import accounts
# import krar

from tkinter import ttk
from .mytheme import Colors
from datetime import datetime

from database import accounts, krar

from .searchbar import SearchBar



class KararPage(tk.Frame):
    def __init__(self, master, **kwargs):
        super().__init__(master, **kwargs)

        # img = tk.PhotoImage(file="myicons\\framebg2.png")

        # self.background_title = tk.Label(self, image=img)
        # self.background_title.place(relx=0, rely=0, relheight=1, relwidth=1)

        # self.img = img

        # main frame to include all frames
        self.main_frame = tk.Frame(self, bg=Colors.BACKGROUND)
        self.main_frame.place(relx=0.3, rely=0.01, relwidth=.4, relheight=.98)

        # self.background_title = tk.Label(self.main_frame, image=img)
        # self.background_title.place(relx=0, rely=0, relheight=1, relwidth=1)



        # title frame
        title_frame = tk.Frame(self.main_frame, bg=Colors.BACKGROUND1)
        title_frame.pack(fill='x', pady=2, padx=10)
        title_name_label = tk.Label(title_frame, text="Krar", font="Consolas 18", bg=Colors.BACKGROUND1, fg=Colors.FG_SHADE_3, anchor='center')
        title_name_label.pack(padx=40, fill='x')

        # Date Entry Box
        date_frame = tk.Frame(self.main_frame, bg=Colors.BACKGROUND)
        date_frame.pack(fill='x', pady=10, padx=10)
        date_label = tk.Label(date_frame, text="Date", font="Consolas 12", bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND, anchor='w')
        date_label.pack(padx=40, fill='x')
        today_date = tk.StringVar(value=datetime.now().strftime('%Y-%m-%d'))
        self.date_entry = tk.Entry(date_frame, textvariable=today_date, font="Consolas 14", bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_1, relief='solid')
        self.date_entry.pack(padx=40, pady=(0,10), fill='x')

        # Account Dropdown Menu
        account_frame  = tk.Frame(self.main_frame, bg=Colors.BACKGROUND)
        account_frame.pack( fill='x', pady=10, padx=10)
        account_label = tk.Label(account_frame, text="Account", font="Consolas 12", bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND, anchor='w')
        account_label.pack(padx=40, fill='x')
        account_choices = self.get_accounts()
        self.account_dropdown = SearchBar(account_frame, data=account_choices)
        self.account_dropdown.set_data(account_choices)
        self.account_dropdown.pack(padx=40, pady=(0, 10), fill='x')
        self.account_dropdown.search_bar.bind('<Enter>', lambda e: self.account_dropdown.set_data(self.get_accounts()))

        # self.account_dropdown = ttk.Combobox(account_frame, values=account_choices, font="Consolas 14")
        # self.account_dropdown.pack(padx=40, pady=(0,10), fill='x')
        # self.account_dropdown.bind('<Enter>', lambda e: self.account_dropdown.config(values=self.get_accounts()))

        # button frame
        button_frame = tk.Frame(self.main_frame, bg=Colors.BACKGROUND)
        button_frame.pack(fill='x', pady=(10,10), padx=10)
        sale_button = tk.Button(button_frame, text="Add krar", font="Consolas 14", command=self.add_krar, bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_3, relief='solid')
        sale_button.pack(padx=40, fill='x', pady=(10, 10))

        # Account dropdown Menu for Settlement
        account_frame2  = tk.Frame(self.main_frame, bg=Colors.BACKGROUND)
        account_frame2.pack( fill='x', pady=10, padx=10)
        account_label2 = tk.Label(account_frame2, text="Account Krar", font="Consolas 12", bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND, anchor='w')
        account_label2.pack(padx=40, fill='x')
        account_choices2 = self.get_accounts_unsettled()
        self.account_dropdown2 = SearchBar(self.main_frame, data=account_choices2)
        self.account_dropdown2.pack(padx=40, pady=(0, 10), fill='x')
        self.account_dropdown2.search_bar.bind('<Enter>', lambda e: self.account_dropdown2.set_data(self.get_accounts_unsettled()))

        # self.account_dropdown2 = ttk.Combobox(account_frame2, values=account_choices2, font="Consolas 14")
        # self.account_dropdown2.pack(padx=40, pady=(0,10), fill='x')
        # self.account_dropdown2.bind('<Enter>', lambda e: self.account_dropdown2.config(values=self.get_accounts_unsettled()))

        # button frame
        button_frame2 = tk.Frame(self.main_frame, bg=Colors.BACKGROUND)
        button_frame2.pack(fill='x', pady=(10,0), padx=10)
        settle_button = tk.Button(button_frame2, text="Settle", font="Consolas 14", command=self.settle_krar, bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_3, relief='solid')
        settle_button.pack(padx=40, fill='x', pady=(10, 10))

    def get_accounts(self):
        account_list = accounts.get_all_customers()
        return [f"{i[0]} {i[1]} {i[2]}" for i in account_list] 
    
    def get_accounts_unsettled(self):
        accounts_list = krar.get_accounts_with_unsettled_krars()
        result_list = []
        for account_id in accounts_list:
            result_list.append(accounts.get_customer_details(account_id))

        return [f"{i[0]} {i[1]} {i[2]}" for i in result_list] 


    def add_krar(self):
        customer_name = self.account_dropdown.get_text()
        krar_date = self.date_entry.get()
        if customer_name and krar_date:
            customer_id = customer_name.split()[0]
            krar_id = krar.add_or_update_krar(customer_id, krar_date)
            if __name__ != "__main__":
                self.master.master.set_status(f"Krar Id : {krar_id}")

    def settle_krar(self):
        customer_name = self.account_dropdown2.get_text()
        if customer_name:
            customer_id = customer_name.split()[0]
            krar.set_krar_settlement(customer_id)
            if __name__ != "__main__":
                self.master.master.set_status(f"Krar Settled for : {customer_id}")




if __name__ == "__main__":
    app = tk.Tk()
    app.state("zoomed")
    h = KararPage(app)
    h.pack(expand=1, fill="both")
    app.mainloop()

 
        
import tkinter as tk

from .mytheme import Colors
from tkinter import ttk
from database import accounts, inventory, database, krar
# import accounts
# import inventory
# import database
# import krar
import sqlite3
from bills import bill_db

class ModifyPage(tk.Frame):
    def __init__(self, master, **kwargs):
        super().__init__(master, **kwargs)

        font = "Consolas 16"

        self.main_frame = tk.Frame(self, bg=Colors.BACKGROUND)
        self.main_frame.place(relx=0.3, rely=0.01, relwidth=.4, relheight=.98)

        # title frame
        title_frame = tk.Frame(self.main_frame, bg=Colors.BACKGROUND1)
        title_frame.pack(fill='x', pady=2, padx=10)
        title_name_label = tk.Label(title_frame, text="Modify Details", font="Consolas 18", bg=Colors.BACKGROUND1, fg=Colors.FG_SHADE_3, anchor='center')
        title_name_label.pack(padx=40, fill='x')

        # Database Dropdown Menu
        database_names = ["accounts.db", "daily_notes.db", "inventory.db", "krar.db", "bills.db"]
        account_frame  = tk.Frame(self.main_frame, bg=Colors.BACKGROUND)
        account_frame.pack( fill='x', pady=10, padx=10)
        account_label = tk.Label(account_frame, text="Database", font="Consolas 12", bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND, anchor='w')
        account_label.pack(padx=40, fill='x')
        self.db_dropdown = ttk.Combobox(account_frame, values=database_names, font="Consolas 14")
        self.db_dropdown.pack(padx=40, pady=(0, 10), fill='x')
        self.db_dropdown.bind('<<ComboboxSelected>>', lambda e : self.update_table_names())
        # self.account_dropdown.bind('<Enter>', lambda e: self.account_dropdown.config(values=self.get_accounts()))
        # self.account_dropdown.bind('<Down>', lambda e: self.update_listbox_items(self.account_dropdown, self.get_accounts(), self.account_dropdown.get().upper()))

        # Table Dropdown Menu
        self.table_list = []
        account_frame  = tk.Frame(self.main_frame, bg=Colors.BACKGROUND)
        account_frame.pack( fill='x', pady=10, padx=10)
        account_label = tk.Label(account_frame, text="Table", font="Consolas 12", bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND, anchor='w')
        account_label.pack(padx=40, fill='x')
        self.table_dropdown = ttk.Combobox(account_frame, values=self.table_list, font="Consolas 14")
        self.table_dropdown.pack(padx=40, pady=(0, 10), fill='x')


        # Row Entry
        date_frame = tk.Frame(self.main_frame, bg=Colors.BACKGROUND)
        date_frame.pack( fill='x', pady=10, padx=10)
        date_label = tk.Label(date_frame, text="Row ID", font="Consolas 12", bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND, anchor='w')
        date_label.pack(padx=40, fill='x')
        self.row_id_var = tk.IntVar()
        self.row_id_entry = tk.Entry(date_frame, font="Consolas 14", textvariable=self.row_id_var, bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_1, relief='solid')
        self.row_id_entry.pack(padx=40, pady=(0,10), fill='x')

        # Show Button
        sale_button_frame  = tk.Frame(self.main_frame, bg=Colors.BACKGROUND)
        sale_button_frame.pack( fill='x', pady=10, padx=10)
        sale_button = tk.Button(sale_button_frame, text="Show", font="Consolas 14", command=self.show_row, bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_3, relief='solid')
        sale_button.pack(padx=40, fill='x', pady=(10, 10))

        # modify row entry
        self.table_row = tk.StringVar()
        date_frame = tk.Frame(self.main_frame, bg=Colors.BACKGROUND)
        date_frame.pack( fill='x', pady=10, padx=10)
        date_label = tk.Label(date_frame, text="Modify Row", font="Consolas 12", bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND, anchor='w')
        date_label.pack(padx=40, fill='x')
        self.modify_row_entry = tk.Entry(date_frame, font="Consolas 14", textvariable=self.table_row, bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_1, relief='solid')
        self.modify_row_entry.pack(padx=40, pady=(0,10), fill='x')

        # Modify Button
        sale_button_frame  = tk.Frame(self.main_frame, bg=Colors.BACKGROUND)
        sale_button_frame.pack( fill='x', pady=10, padx=10)
        sale_button = tk.Button(sale_button_frame, text="Modify", font="Consolas 14", command=self.modify_row_function, bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_3, relief='solid')
        sale_button.pack(padx=40, fill='x', pady=(10, 10))

        # Delete Button
        sale_button_frame  = tk.Frame(self.main_frame, bg=Colors.BACKGROUND)
        sale_button_frame.pack( fill='x', pady=10, padx=10)
        sale_button = tk.Button(sale_button_frame, text="Delete", font="Consolas 14", command=self.delete_row_function, bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_3, relief='solid')
        sale_button.pack(padx=40, fill='x', pady=(10, 10))

        # # --------------------------------------------------------
        # self.upper_frame = tk.Frame(self, bg=Colors.ACTIVE_BACKGROUND)
        # # self.upper_frame.place(relx=0, rely=0, relheight=0.2, relwidth=1)
        # # self.table_selector()

        # self.table_frame = tk.Frame(self, bg=Colors.ACTIVE_BACKGROUND)
        # # self.table_frame.place(relx=0, rely=0.2, relheight=0.8, relwidth=1)

        # # self.table_row = tk.StringVar()

        # row_label = tk.Label(self.table_frame, text="Table Row", bg=Colors.ACTIVE_BACKGROUND, font=font)
        # row_label.place(relx=0.1, rely=0.1, relheight=0.1, relwidth=0.8)
        # row_entry = tk.Entry(self.table_frame, textvariable=self.table_row, font=font, bg=Colors.ACTIVE_BACKGROUND)
        # row_entry.place(relx=0.1, rely=0.2, relheight=0.1, relwidth=0.8)

        # # Create button
        # modify_row_button = tk.Button(self.table_frame, text="Modify Data", command=self.modify_row_function, bg=Colors.ACTIVE_BACKGROUND, font=font)
        # modify_row_button.place(relx=0.18, rely=0.4, relheight=0.1, relwidth=0.3)
        # delete_row_button = tk.Button(self.table_frame, text="Delete Data", command=self.delete_row_function, bg=Colors.ACTIVE_BACKGROUND, font=font)
        # delete_row_button.place(relx=0.52, rely=0.4, relheight=0.1, relwidth=0.3)




        # self.default_lable = tk.Label(self.table_frame, bg=Colors.ACTIVE_BACKGROUND, text="Select a table", font="Consolas 36")
        # self.default_lable.pack(expand=1, fill=tk.BOTH)


    
    # def table_selector(self):
    #     font = "Consolas 16"
    #     database_names = ["accounts.db", "daily_notes.db", "inventory.db", "krar.db"]
    #     labels_top_frame = tk.Frame(self.upper_frame, bg=Colors.ACTIVE_BACKGROUND)
    #     labels_top_frame.pack(side="top", fill=tk.BOTH)
    #     labels_bottom_frame = tk.Frame(self.upper_frame, bg=Colors.ACTIVE_BACKGROUND)
    #     labels_bottom_frame.pack(side="top", fill=tk.BOTH)
        
        
    #     db_label = tk.Label(labels_top_frame, text="Select database:", bg=Colors.ACTIVE_BACKGROUND, font=font)
    #     db_label.pack(side="left", padx=5, pady=5)
    #     self.db_dropdown = ttk.Combobox(labels_bottom_frame, values=database_names, font=font)
    #     self.db_dropdown.pack(side="left", padx=5, pady=5)
    #     self.db_dropdown.bind('<<ComboboxSelected>>', lambda e : self.update_table_names())


    #     # self.db_dropdown.bind('<Enter>', lambda e: db_dropdown.config(values=get_item_list()))
    #     # self.db_dropdown.bind('<Down>', lambda e: update_listbox_items(db_dropdown, get_item_list(), b_in1.get()))


    #     # Create table dropdown
    #     self.table_list = []
    #     table_label = tk.Label(labels_top_frame, text="Select table:", bg=Colors.ACTIVE_BACKGROUND, font=font)
    #     table_label.pack(side="left", padx=80, pady=5)
    #     self.table_dropdown = ttk.Combobox(labels_bottom_frame, values= self.table_list, width=20, font=font)
    #     self.table_dropdown.pack(side="left", padx=5, pady=5)
    #     # self.table_dropdown.bind('<<ComboboxSelected>>', lambda e : self.update_table_names())

    #     row_label = tk.Label(labels_top_frame, text="Row id:", bg=Colors.ACTIVE_BACKGROUND, font=font)
    #     row_label.pack(side="left", padx=50, pady=5)
    #     self.row_id_entry = tk.Entry(labels_bottom_frame, font=font, bg=Colors.ACTIVE_BACKGROUND)
    #     self.row_id_entry.pack(side="left", padx=5, pady=5)

    #     # Create button
    #     show_button = tk.Button(labels_bottom_frame, text="Show Data", command=self.show_row, bg=Colors.ACTIVE_BACKGROUND, font=font)
    #     show_button.pack(side="left", padx=5, pady=5)

    def update_table_names(self):
        selected_db = self.db_dropdown.get()
        if selected_db:
            if selected_db == "accounts.db":
                accounts.accounts_cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
                self.table_list = accounts.accounts_cursor.fetchall()
            if selected_db == "inventory.db":
                inventory.inventory_cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
                self.table_list = inventory.inventory_cursor.fetchall()
            if selected_db == "daily_notes.db":
                database.daily_cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
                self.table_list = database.daily_cursor.fetchall()
            if selected_db == "krar.db":
                krar.cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
                self.table_list = krar.cursor.fetchall()
            if selected_db == "bills.db":
                conn = sqlite3.connect(bill_db.db_name)
                cursor = conn.cursor()
                cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
                self.table_list = cursor.fetchall()
                conn.close()
            
            self.table_dropdown.config(values=self.table_list)
            
            # print(selected_db, self.table_list)

    def show_row(self):
        # Get selected database and table
        selected_db = self.db_dropdown.get()
        selected_table = self.table_dropdown.get()
        row_id = self.row_id_entry.get()
        
        row = []
        if selected_db and selected_table:
            if selected_db == "accounts.db":
                row = accounts.get_transaction_by_id(selected_table, int(row_id) )

            if selected_db == "inventory.db":
                row = inventory.get_transaction_by_id(selected_table, row_id)

            if selected_db == "daily_notes.db":
                if __name__ == "__main__":
                    print("cannot modify daily_note")
                
                else:
                    self.master.master.set_status("[-] Cannot modify daily_notes")
            
            if selected_db == "krar.db":
                if selected_table == "all_krar":
                    x = 'krar_id'
                else:
                    x = 'uid'
                row = krar.cursor.execute(f"SELECT * FROM {selected_table} where {x} = {row_id}").fetchone()

            if selected_db == "bills.db":
                conn = sqlite3.connect(bill_db.db_name)
                cursor = conn.cursor()
                row = cursor.execute(f"SELECT * FROM {selected_table} where id = {row_id}").fetchone()
                conn.close()

        new_row = "|".join(map(str, row))
        self.table_row.set(new_row)
    
    def modify_row_function(self):
        table_row = self.table_row.get().upper()
        selected_db = self.db_dropdown.get()
        selected_table = self.table_dropdown.get()
        row_id = self.row_id_entry.get()
        if table_row and selected_db and selected_table and row_id:
            row_list = table_row.split("|")
            if selected_db == "accounts.db":
                if selected_table == "customers":
                    accounts.update_customer_details(row_id, row_list[1], row_list[2])
                                        
                else:
                    accounts.update_customer_transaction(selected_table, row_id, row_list[1], row_list[2], row_list[3], row_list[4], row_list[5])
                    
            if selected_db == "inventory.db":
                if selected_table == "items":
                    inventory.modify_item(row_id, row_list[1], row_list[2], row_list[3], row_list[4], row_list[5], row_list[6], row_list[7], row_list[8], row_list[9])
                                        
                else:
                    item_id  = int(selected_table.split("_")[1])
                    inventory.modify_transaction(item_id, row_id, row_list[1], row_list[2], row_list[3], row_list[4], row_list[5])

            if selected_db == "krar.db":
                if selected_table == "all_krar":
                    krar.modify_krar_customer_and_status(int(row_id), row_list[1], row_list[2])
                else:
                    krar.modify_by_krar_id(int(row_id), row_list[1], row_list[2])

            if selected_db == 'bills.db':
                conn = sqlite3.connect(bill_db.db_name)
                cursor = conn.cursor()
                if selected_table == "item_details":
                    bill_db.modify_item_details(int(row_id), tuple(row_list[1:]))
                
                elif selected_table == "bill_details":
                    bill_db.modify_bill_details(int(row_list[1]), tuple(row_list[2:]))
                
                else:
                    bill_db.modify_bill_item(int(row_list[1]), int(row_list[2]), int(row_list[3]))

            note = f"05 = {selected_db}, {selected_table}, {row_id}, {table_row}"
            database.add_note_to_date(note)

            
            if __name__ != "__main__":
                self.master.master.set_status(f"Row updated: {row_id}")
                    
                    

    def delete_row_function(self):
        table_row = self.table_row.get().upper()
        selected_db = self.db_dropdown.get()
        selected_table = self.table_dropdown.get()
        row_id = self.row_id_entry.get()
        if selected_db and selected_table and row_id:
            if selected_db == "accounts.db":
                if selected_table == "customers":
                    accounts.delete_customer(row_id)
                
                else:
                    customer_id = int(selected_table.split("_")[1])
                    accounts.delete_customer_transaction(customer_id, row_id)

            if selected_db == "inventory.db":
                if selected_table == "items":
                    inventory.delete_item(row_id)
                
                else:
                    item_id = int(selected_table.split("_")[1])
                    inventory.delete_transaction(item_id, row_id)

            if selected_db == "krar.db":
                if selected_table == "all_krar":
                    krar.delete_from_all_krar(int(row_id))
                else:
                    krar.delete_from_by_krar_id(int(row_id))
            
            if selected_db == 'bills.db':
                bill_db.delete_row(selected_table, row_id)


            note = f"06 = {selected_db}, {selected_table}, {row_id}, {table_row}"
            database.add_note_to_date(note)
            if __name__ != "__main__":
                self.master.master.set_status(f"Row deleted: {row_id}")
                


if __name__ == "__main__":
    app = tk.Tk()
    app.state("zoomed")
    h = ModifyPage(app)
    h.pack(expand=1, fill="both")
    app.mainloop()

 


class Colors1:
    BACKGROUND = "#2C3333"
    BACKGROUND1 = "#1C2323"
    BACKGROUND2 = "#2f3636"
    BACKGROUND3 = "#353c3c"
    BACKGROUND4 = "#454c4c"
    BACKGROUND5 = "#555c5c"
    ACTIVE_BACKGROUND = "#2E4F4F"
    ACTIVE_FOREGROUND = "#0E8388"
    FOREGROUND = "#CBE4D0"
    
    BG_SHADE_1 = "#1b2222"
    BG_SHADE_2 = "#1b2232"
    BG_SHADE_3 = "#475151"
    
    FG_SHADE_1 = "#1cb9c8"
    FG_SHADE_2 = "#ffffff"
    FG_SHADE_3 = "#22c95a"
    
    LIGHT_BG = "#354040"
    LIGHT_FG = "#D2E7E0"
    
    SUCCESS = "#7CB342"
    ERROR = "#E53935"
    REMINDER = "#FB8C00"
    DELETE = "#6C2323"

class Colors:
    BACKGROUND = "#F5F5F5" 
    BACKGROUND1 = "#E8E8E8"  
    BACKGROUND2 = "#E0E0E0" 
    BACKGROUND3 = "#D8D8D8" 
    BACKGROUND4 = "#BBB"
    BACKGROUND5 = "#AAA"
    ACTIVE_BACKGROUND = "#CCEEFF" 
    ACTIVE_FOREGROUND = "#0077BB" 
    FOREGROUND = "#333333" 
    BG_SHADE_1 = "#DADADA" 
    BG_SHADE_2 = "#C2C2C2" 
    BG_SHADE_3 = "#AAAAAA" 
    FG_SHADE_1 = "#0077BB"
    FG_SHADE_2 = "#333333" 
    FG_SHADE_3 = "#00994C"

    LIGHT_FG = "#354040"   
    LIGHT_BG = "#D2E7E0"

    SUCCESS = "#7CB342"  
    ERROR = "#CC0000"   
    REMINDER = "#F57C00" 
    DELETE = "#A42929"


 

 
        
import tkinter as tk

from .mytheme import Colors
from tkinter import ttk
from tkinter import filedialog, messagebox

import openpyxl
import calendar
import datetime
import os
import re
import sqlite3
import sys

import numpy as np
# import pandas as pd

from database import accounts, inventory, database, krar, crop_database
# import accounts
# import inventory
# import database
# import krar
import numpy as np
import pandas as pd

db_name = "C://JBB//data//bills.db"
bill_cursor = sqlite3.connect(db_name).cursor()
# import mypandasfile

class ReportsPage(tk.Frame):
    # accounts_df = mypandasfile.customer_df

    def __init__(self, master, **kwargs):
        super().__init__(master, **kwargs)
        self.Colors = Colors

        # img = tk.PhotoImage(file="myicons\\framebg2.png")

        # self.background_title = tk.Label(self, image=img)
        # self.background_title.place(relx=0, rely=0, relheight=1, relwidth=1)

        # self.img = img

        self.upper_frame = tk.Frame(self, bg=Colors.BACKGROUND)
        self.upper_frame.place(relx=0.01, rely=0.01, relheight=0.09, relwidth=0.98)
        self.table_selector()

        self.table_frame = tk.Frame(self, bg=Colors.BACKGROUND)
        self.table_frame.place(relx=0.01, rely=0.11, relheight=0.88, relwidth=0.98)

        # self.default_lable = tk.Label(self.table_frame, bg=Colors.ACTIVE_BACKGROUND, text="Select a table", font="Consolas 36")
        # self.default_lable.pack(expand=1, fill=tk.BOTH)

        # self.sort_by_dropdown.set("Customer Id")
        # self.sort_by_combobox_select()


    
    def table_selector(self):
        font = "Consolas 16"
        database_names = ["accounts.db", "inventory.db", "daily_notes.db", "krar.db", "bills.db"]
        db_label = tk.Label(self.upper_frame, text="Database:", bg=self.Colors.BACKGROUND, fg=self.Colors.ACTIVE_FOREGROUND, font=font)
        db_label.pack(side="left", padx=5, pady=5)
        self.db_dropdown = ttk.Combobox(self.upper_frame, values=database_names, width=12, font=font)
        self.db_dropdown.pack(side="left", padx=5, pady=5)
        self.db_dropdown.bind('<<ComboboxSelected>>', lambda e : self.update_table_names())


        # self.db_dropdown.bind('<Enter>', lambda e: db_dropdown.config(values=get_item_list()))
        # self.db_dropdown.bind('<Down>', lambda e: update_listbox_items(db_dropdown, get_item_list(), b_in1.get()))


        # Create table dropdown
        self.table_list = []
        table_label = tk.Label(self.upper_frame, text="Table:", bg=self.Colors.BACKGROUND, fg=self.Colors.ACTIVE_FOREGROUND, font=font)
        table_label.pack(side="left", padx=5, pady=5)
        # self.table_dropdown = SearchBar(self.upper_frame, data=self.table_list)
        # self.table_dropdown.pack(padx=40, pady=(0, 10), fill='x')
        # self.table_dropdown.search_bar.bind('<Enter>', lambda e: self.table_dropdown.set_data(self.table_list))

        self.table_dropdown = ttk.Combobox(self.upper_frame, values= self.table_list, width=20, font=font)
        self.table_dropdown.pack(side="left", padx=5, pady=5)
        self.table_dropdown.bind('<Down>', lambda e: self.update_listbox_items(self.table_dropdown, self.table_list, self.table_dropdown.get().upper()))
        self.table_dropdown.bind('<<ComboboxSelected>>', lambda e: self.show_table())
        # self.table_dropdown.bind('<<ComboboxSelected>>', lambda e : self.update_table_names())

        # Create button
        # show_button = tk.Button(self.upper_frame, text="Show", command=self.show_table, bg=self.Colors.BACKGROUND3, fg=self.Colors.FG_SHADE_3, relief='solid', font="Consolas 14")
        # show_button.pack(side="left", padx=5, pady=5)

        export_button = tk.Button(self.upper_frame, text="Export", command=self.export_to_excel, bg=self.Colors.BACKGROUND, fg=self.Colors.FG_SHADE_3, relief='solid', font="Consolas 14")
        export_button.pack(side="left", padx=30, pady=5)

    def parallel_process_combo(self, accounts_df):
        for widget in self.upper_frame.winfo_children():
            widget.destroy()
        # sort by
        self.table_selector()
        self.accounts_df = accounts_df
        self.accounts_df = self.calculate_account_score(self.accounts_df)
        self.accounts_df = self.accounts_df[['customer_id', 'name', 'detail', 'Amount', 'Days', 'account_score']]
        sort_options_list = ['Customer Id', 'Amount', 'Days', 'Customer Id R', 'Amount R', "Days R", "Score"]
        self.sort_by_dropdown = ttk.Combobox(self.upper_frame, values=sort_options_list, width=20, font="Consolas 16")
        self.sort_by_dropdown.pack(side="left", padx=5, pady=5)
        self.sort_by_dropdown.bind('<<ComboboxSelected>>', lambda e : self.sort_by_combobox_select())
        self.sort_by_dropdown.set("Customer Id")
        self.sort_by_combobox_select()
        
    def sort_by_combobox_select(self):
        value = self.sort_by_dropdown.get()
        if value == "Amount":
            self.make_my_table(self.accounts_df.sort_values('Amount'))
        elif value == "Days":
            self.make_my_table(self.accounts_df.sort_values('Days'))
        elif value == "Customer Id":
            self.make_my_table(self.accounts_df.sort_values('customer_id'))
        elif value == "Amount R":
            self.make_my_table(self.accounts_df.sort_values('Amount', ascending=False))
        elif value == "Days R":
            self.make_my_table(self.accounts_df.sort_values('Days', ascending=False))
        elif value == "Customer Id R":
            self.make_my_table(self.accounts_df.sort_values('customer_id', ascending=False))
        elif value == "Score":
            self.make_my_table(self.accounts_df.sort_values('account_score', ascending=False))
        else:
            self.make_my_table(self.accounts_df)
    
    
    def calculate_account_score(self, df, alpha=0.6, beta=0.4):
        """
        Calculates an account score based on log-transformed amount and days,
        and adds it as a new 'account_score' column to the DataFrame.
        """
        # Avoid modifying the original DataFrame in place
        df_copy = df.copy()

        # Handle cases where amount is zero or negative to avoid log(0) or log(negative)
        df_copy['log_amount'] = df_copy['Amount'].apply(lambda x: np.log(x + 1) if x > 0 else 0)
        df_copy['log_days'] = df_copy['Days'].apply(lambda x: np.log(x + 1) if x > 0 else 0)

        # Normalize log_amount and log_days
        min_log_amount = df_copy['log_amount'].min()
        max_log_amount = df_copy['log_amount'].max()
        min_log_days = df_copy['log_days'].min()
        max_log_days = df_copy['log_days'].max()

        if max_log_amount - min_log_amount != 0:
          df_copy['normalized_log_amount'] = (df_copy['log_amount'] - min_log_amount) / (max_log_amount - min_log_amount)
        else:
          df_copy['normalized_log_amount'] = 0

        if max_log_days - min_log_days != 0:
          df_copy['normalized_log_days'] = (df_copy['log_days'] - min_log_days) / (max_log_days - min_log_days)
        else:
          df_copy['normalized_log_days'] = 0

        # Calculate the account score
        df_copy['account_score'] = (alpha * df_copy['normalized_log_amount']) + (beta * df_copy['normalized_log_days'])
        return df_copy

    def make_my_table(self, df):
        self.db_dropdown.set("Root")
        for widget in self.table_frame.winfo_children():
                widget.destroy()
        # columns = df.columns.tolist()
        column_name = ["ID", "Name", "Details", "Amount", "Active", "Score", "-"]
            
        self.tree = ttk.Treeview(self.table_frame)
        self.tree['columns'] = column_name
        self.tree.heading("#0", text="")
        self.tree.column('#0', width=20, stretch="no")
        column_width_list = [45, 300, 300, 120, 120, 100, 120]
        # for column in columns:
        #     self.tree.heading(column, text=column)
        
        for i in range(len(column_name)):
            self.tree.column(column_name[i], width=column_width_list[i], anchor='w')
            self.tree.heading(column_name[i], text=column_name[i], anchor="w")
        
        
        c = 0
        for index, row in df.iterrows():
            score = int(round(row.tolist()[5], 2) * 100)
            tg= f'e{score}' if c%2 else f'o{score}'
            c += 1
            parent_id = self.tree.insert("", 'end', text=c, values=row.tolist(), tags=tg)
            self.tree.tag_configure(tg, background=self.calculate_color_value(tg), foreground="#FFF")

            c2 = 0
            for row in self.tree_subtree_accounts(row.tolist()[0]):
                tg1 = 'even1' if c2%2 else "odd1"
                self.tree.insert(parent_id, 'end', values=row, tags=tg1)
                c2 += 1
            
        # self.tree.tag_configure('odd', background=self.Colors.BACKGROUND, foreground=self.Colors.ACTIVE_FOREGROUND)
        # self.tree.tag_configure('even', background=self.Colors.BACKGROUND1, foreground=self.Colors.ACTIVE_FOREGROUND)
        self.tree.tag_configure('odd1', background=self.Colors.BACKGROUND4, foreground=self.Colors.ACTIVE_FOREGROUND)
        self.tree.tag_configure('even1', background=self.Colors.BACKGROUND5, foreground=self.Colors.ACTIVE_FOREGROUND)
        self.tree.pack(fill=tk.BOTH, expand=True, side=tk.TOP)
        
        # self.tree.bind("<Double-1>", self.on_double_click1)

    def calculate_color_value(self, tg):
        tag =  tg[0]
        score = int(tg[1:])/100
        hex_val = int(60*score)
        red_hex = hex(196+hex_val)[2:].zfill(2) 
        red = hex(int(score*255))[2:].zfill(2)
        green = hex(int((1-score)*255))[2:].zfill(2)

        # return f"#{red}{green}CC"
        return f"#88{green}{red}"

        # if score < .5:
        #     return f"#00{red_hex}00"
        # else:
        #     return f"#{red_hex}0000"
        # if tag == "e":
        #     return f"#{red_hex}CCCC"
        # else:
        #     return f"#{red_hex}CCCC"

    def update_table_names(self):
        selected_db = self.db_dropdown.get()
        if selected_db:
            if selected_db == "accounts.db":
                self.table_list = ['customers']
                for account in accounts.get_all_customers_name_and_id():
                    self.table_list.append(f"{account[0]} {account[1]}")
                # self.table_list = [f"{i[0]} {i[1]}" for i in table_list]
                # accounts.accounts_cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
                # self.table_list = accounts.accounts_cursor.fetchall()
                self.table_dropdown.set("customers")
            if selected_db == "inventory.db":
                self.table_list = ['items']
                for item in inventory.get_all_items_id_and_name():
                    self.table_list.append(f"{item[0]} {item[1]}")
                # inventory.inventory_cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
                # self.table_list = inventory.inventory_cursor.fetchall()
                self.table_dropdown.set("items")
            if selected_db == "daily_notes.db":
                database.daily_cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
                self.table_list = database.daily_cursor.fetchall()
                today_date = datetime.date.today()
                if today_date.month<10:
                    self.table_dropdown.set(f"d{today_date.year}_0{today_date.month}_{today_date.day}")
                else:
                    self.table_dropdown.set(f"d{today_date.year}_{today_date.month}_{today_date.day}")
            if selected_db == "krar.db":
                krar.cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
                self.table_list = krar.cursor.fetchall()
                self.table_dropdown.set("all_krar")
            if selected_db == "bills.db":
                bill_cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
                self.table_list = bill_cursor.fetchall()
                self.table_dropdown.set("item_details")
            
            self.table_dropdown.config(values=self.table_list)
            self.show_table()
            # print(selected_db, self.table_list)

    def show_data(self):
        # Get selected database and table
        selected_db = self.db_dropdown.get()
        selected_table = self.table_dropdown.get()
        column_names = []
        column_list = []
        table_data = []
        column_width_list= [1,1,1,1,1,1,1,1,1,1]
        tag = 0
        if selected_db and selected_table:
            if selected_db == "accounts.db":
                tag = 1
                # table_id = self.table_dropdown.get().split("_")[1]  # Extract customer ID
                # self.generate_compound_interest_report(table_id)
                if selected_table != 'customers':
                    selected_table = f"customer_{selected_table.split()[0]}"
                accounts.accounts_cursor.execute(f"PRAGMA table_info({selected_table})")
                column_list = accounts.accounts_cursor.fetchall()
                table_data = accounts.get_table(selected_table)
                column_names, table_data, column_width_list = self.make_table_accounts(column_list, table_data)
                

            if selected_db == "inventory.db":
                tag = 1
                if selected_table != 'items':
                    selected_table = f"item_{selected_table.split()[0]}"
                inventory.inventory_cursor.execute(f"PRAGMA table_info({selected_table})")
                column_list = inventory.inventory_cursor.fetchall()
                table_data = inventory.get_table(selected_table)
                column_names, table_data, column_width_list = self.make_table_items(column_list, table_data)

            if selected_db == "daily_notes.db":
                database.daily_cursor.execute(f"PRAGMA table_info({selected_table})")
                column_list = database.daily_cursor.fetchall()
                table_data = database.get_table(selected_table)

            if selected_db == "krar.db":
                krar.cursor.execute(f"PRAGMA table_info({selected_table})")
                column_list = krar.cursor.fetchall()
                table_data = krar.cursor.execute(f"SELECT * FROM {selected_table}").fetchall()

            if selected_db == "bills.db":
                bill_cursor.execute(f"PRAGMA table_info({selected_table})")
                column_list = bill_cursor.fetchall()
                table_data = bill_cursor.execute(f"SELECT * FROM {selected_table}").fetchall()

        # print(column_list)
        if tag:
            pass
        else:
            for column in column_list:
                column_names.append(column[1])
        
        return column_names, table_data, column_width_list
    
    def show_table(self):
        column_name, table_data, column_width_list = self.show_data()
        if column_name and table_data:
            for widget in self.table_frame.winfo_children():
                    widget.destroy()
                
            self.tree = ttk.Treeview(self.table_frame)
            self.tree['columns'] = column_name
            self.tree.column('#0', width=0, stretch='no')


            for i in range(len(column_name)):
                self.tree.column(column_name[i], width=column_width_list[i], anchor='w')
                self.tree.heading(column_name[i], text=column_name[i], anchor="w")
            
            c = 0
            for i in table_data:
                c += 1
                tg = 'odd'
                if c%2 == 0:
                    tg = "even"
                self.tree.insert('', c, text=c, values=i, tags = tg)

            # tree.tag_configure('odd', background="#fff")
            # tree.tag_configure('even', background="#fafafa")
            self.tree.tag_configure('odd', background=self.Colors.BACKGROUND, foreground=self.Colors.ACTIVE_FOREGROUND)
            self.tree.tag_configure('even', background=self.Colors.BACKGROUND1, foreground=self.Colors.ACTIVE_FOREGROUND)
            self.tree.pack(fill=tk.BOTH, expand=True, side=tk.TOP)
            if self.table_dropdown.get() in ['customers', 'items']:
                self.tree.bind("<Double-1>", self.on_double_click)
            self.tree.bind("<Control-Button-1>", self.on_control_click)
        else:
            if __name__ != "__main__":
                self.master.master.set_status("Data Not Avilable")
            print("Empty fields for reports")

    def on_double_click(self, event):
        """Handles double-click event on Treeview items and retrieves the ID."""
        region = self.tree.identify("region", event.x, event.y)
        if region == "cell":
            item_id = self.tree.identify_row(event.y)
            # print(f"Double-clicked item ID: {item_id}") 
            row_data = self.tree.item(item_id)['values']
            if self.db_dropdown.get() == "accounts.db":
                self.table_dropdown.set(f"{row_data[0]} {row_data[1]}")
            else:
                self.table_dropdown.set(f"{row_data[0]} {row_data[1]}")
            self.show_table()
    
    def on_double_click1(self, event):
        region = self.tree.identify("region", event.x, event.y)
        if region == "cell":
            item_id = self.tree.identify_row(event.y)
            # print(f"Double-clicked item ID: {item_id}") 
            row_data = self.tree.item(item_id)['values']
            self.db_dropdown.set("accounts.db")
            self.table_dropdown.set(f"{row_data[0]} {row_data[1]}")
            self.show_table()


    def on_control_click(self, event):
        """Handles double-click event on Treeview items and retrieves the ID."""
        region = self.tree.identify("region", event.x, event.y)
        if region == "cell" and __name__ != "__main__":
            item_id = self.tree.identify_row(event.y)
            # print(f"Double-clicked item ID: {item_id}")
            row_id = self.tree.item(item_id)['values'][0]
            # print(row_id[0])
            table_name = self.table_dropdown.get()
            db_name = self.db_dropdown.get()
            if db_name == 'accounts.db' and table_name!= 'customers':
                table_name = f'customer_{table_name.split()[0]}'
            elif db_name == 'inventory.db' and table_name != 'items':
                table_name = f'item_{table_name.split()[0]}'
    
            self.master.master.modifyframe.db_dropdown.set(db_name)
            self.master.master.modifyframe.table_dropdown.set(table_name)
            self.master.master.modifyframe.row_id_var.set(row_id)
            self.master.master.modifyframe.show_row()
            self.master.master.modify_frame_label.set_active()
            self.master.master.report_frame_label.set_inactive()

    
    def update_listbox_items(self, lb, lst, pat):
        lsts = []
        if self.db_dropdown.get() in ['inventory.db', 'accounts.db']:
            for i in lst:
                if re.search(pat, i):
                    lsts.append(i)
            lb.config(values=lsts)
        elif self.db_dropdown.get() == "daily_notes.db":
            for i in lst:
                if re.search(pat, i[0]):
                    lsts.append(i)
            lb.config(values=lsts)


    # important funcition for simple intrest
    def calculate_interest1(self, amt, from_date, today_date_1=datetime.date.today()):
        interest_rate_one_day = 0.0006575342465753425
        dt2 = from_date.split("-")
        date_of_entry = datetime.date(int(dt2[0]), int(dt2[1]), int(dt2[2]))
        date_difference = today_date_1 - date_of_entry
        interest = amt*date_difference.days*interest_rate_one_day
        return round(interest, 2)
    
    
    def calculate_interest(self, principle_amount, from_date_str, to_date=datetime.date.today()):
        """
        Calculates interest earned on a principle amount, considering financial year-end (March 31st).

        Args:
            principle_amount (float): The initial amount of money.
            from_date_str (str): The starting date for interest calculation in "YYYY-MM-DD" format.
            to_date (datetime.date, optional): The ending date for interest calculation. Defaults to today.

        Returns:
            float: The calculated interest amount.
        """
        daily_interest_rate = 0.0006575342465753425 
        from_date = datetime.datetime.strptime(from_date_str, "%Y-%m-%d").date()
        total_interest = 0

        while from_date < to_date:
            year_end = datetime.date(from_date.year, 3, 31) 
            if from_date.month > 3:
                year_end = datetime.date(from_date.year + 1, 3, 31)
            end_date = min(year_end, to_date)
            days = (end_date - from_date).days
            interest = principle_amount * days * daily_interest_rate
            total_interest += interest
            principle_amount += interest 
            from_date = end_date + datetime.timedelta(days=1)

        return round(total_interest, 2)

    def make_table_accounts1(self, column_list, table_data):
        total_sum = 0.0
        total_sum_without_interest = 0.0
        total_interest = 0.0
        updated_column_list = []
        updated_table_data = []
        # print(column_list)
        for i in column_list:
            updated_column_list.append(i[1])
        if len(column_list) == 3:
            updated_table_data = table_data
            column_width_list = [10, 400, 400]
        else:
            column_width_list = [10, 50, 400, 10, 40, 40, 50]
            updated_column_list = ['ID', 'Date', 'Particulars', 'Intrest', 'Debit', 'Credit', 'Balance']
    
            for row in table_data:
                date = row[1]
                amount = row[3]
                transction_type = row[4]
                tag = row[5]
                if tag == "1":
                    intrest = self.calculate_interest(amount, date)
                elif tag == "0":
                    intrest = 0
                    amount = 0
                else:
                    intrest = 0
                ttl = float(amount) + intrest
                if transction_type.upper() == "P":
                    debit = amount
                    credit =  "" 
                    total_interest += intrest
                    total_sum_without_interest += float(amount)
                    total_sum += ttl
                else:
                    debit = ""
                    credit =  amount
                    total_interest -= intrest
                    total_sum_without_interest -= float(amount)
                    total_sum -= ttl
                temp_list = [row[0], date, row[2], intrest, debit, credit, total_sum_without_interest]
                # for i in row:
                #     temp_list.append(i)
                # temp_list.append(intrest)
                updated_table_data.append(temp_list)
            if __name__ != "__main__":
                table_id = self.table_dropdown.get().split()[0]
                customer_name = accounts.get_customer_details(table_id)
                status = f"{customer_name}    {round(total_sum_without_interest,2)} + {round(total_interest, 2)} = {round(total_sum,2)} "
                self.master.master.set_status(status)
        return updated_column_list, updated_table_data, column_width_list
    

    def make_table_accounts(self, column_list, table_data):
        """Prepares account transaction data for display, 
            including interest and settlement handling.
        """
        total_sum_without_interest = 0.0
        total_interest = 0.0
        updated_column_list = []
        updated_table_data = []

        for i in column_list:
            updated_column_list.append(i[1])

        if len(column_list) == 3:  # Assuming 'customers' table
            updated_table_data = table_data
            column_width_list = [10, 400, 400]
        else:
            column_width_list = [10, 50, 400, 10, 40, 40, 50]
            updated_column_list = ['ID', 'Date', 'Particulars', 'Interest', 'Debit', 'Credit', 'Balance']

            current_balance = 0.0
            last_settlement_date, last_settlement_id = self._find_last_settlement_date(table_data)
            # Keep track of the last settlement transaction ID

            for row in table_data:
                id, date, particulars, amount, transaction_type, tag = row
                date_obj = datetime.datetime.strptime(date, "%Y-%m-%d").date()
                interest = 0.0
                debit = amount if transaction_type.upper() == "P" else ""
                credit = amount if transaction_type.upper() == "M" else ""

                if tag == '0':  # Settlement transaction
                    current_balance = 0.0
                    total_interest = 0.0
                    total_sum_without_interest = 0.0
                    last_settlement_date = date_obj

                else: 
                    # Calculate interest only if transaction is after the last settlement
                    if (tag == '1' and 
                        (last_settlement_date is None or 
                            date_obj > last_settlement_date or 
                            (date_obj == last_settlement_date and id > last_settlement_id))
                    ):
                        interest = self.calculate_interest(amount, date)
                        total_interest += (interest if transaction_type.upper() == "P" else -interest)

                    current_balance += (amount if transaction_type.upper() == "P" else -amount)
                    total_sum_without_interest += (amount if transaction_type.upper() == "P" else -amount)

                temp_list = [id, date, particulars, interest, debit, credit, current_balance] 
                updated_table_data.append(temp_list)

            if __name__ != "__main__" and self.db_dropdown.get() != "Root":
                table_id = self.table_dropdown.get().split()[0]
                customer_name = accounts.get_customer_details(table_id)
                status = (
                    f"{customer_name}    "
                    f"{round(total_sum_without_interest, 2)} + "
                    f"{round(total_interest, 2)} = "
                    f"{round(total_sum_without_interest + total_interest, 2)}"
                )
                self.master.master.set_status(status)

        return updated_column_list, updated_table_data, column_width_list

    def calculate_total123(self):
        t1 = 0
        t2 = 0
        t3 = 0
        t4 = 0
        t5 = 0
        t6 = 0
        for account in accounts.get_all_customers_name_and_id():
            selected_table = f"customer_{account[0]}"
            table_data = accounts.get_table(selected_table)
            x,y,z = self.get_total_amount123(table_data)
            if z>0:
                t1 += x
                t2 += y
                t3 += z
            else:
                t4 += x
                t5 += y
                t6 += z
                
            print(account[0], account[1], x, y, z)
        
        print()
        print(t1, t2, t3)
        print()
        print(t4, t5, t6)
        print()
        print()
        print(t1+t4, t2+t5, t6+t3)

    def get_total_amount123(self, table_data):
        total_sum_without_interest = 0.0
        total_interest = 0.0

        # for i in column_list:
        #     updated_column_list.append(i[1])
        # updated_column_list = ['ID', 'Date', 'Particulars', 'Interest', 'Debit', 'Credit', 'Balance']
        current_balance = 0.0
        last_settlement_date, last_settlement_id = self._find_last_settlement_date(table_data)
        # Keep track of the last settlement transaction ID
        for row in table_data:
            id, date, particulars, amount, transaction_type, tag = row
            date_obj = datetime.datetime.strptime(date, "%Y-%m-%d").date()
            interest = 0.0
            debit = amount if transaction_type.upper() == "P" else ""
            credit = amount if transaction_type.upper() == "M" else ""
            if tag == '0':  # Settlement transaction
                current_balance = 0.0
                total_interest = 0.0
                total_sum_without_interest = 0.0
                last_settlement_date = date_obj
            else: 
                # Calculate interest only if transaction is after the last settlement
                if (tag == '1' and 
                    (last_settlement_date is None or 
                        date_obj > last_settlement_date or 
                        (date_obj == last_settlement_date and id > last_settlement_id))
                ):
                    interest = self.calculate_interest(amount, date)
                    total_interest += (interest if transaction_type.upper() == "P" else -interest)
                current_balance += (amount if transaction_type.upper() == "P" else -amount)
                total_sum_without_interest += (amount if transaction_type.upper() == "P" else -amount)
            # temp_list = [id, date, particulars, interest, debit, credit, current_balance] 
            # updated_table_data.append(temp_list)

        return [total_sum_without_interest, total_interest, total_sum_without_interest + total_interest]

    def _find_last_settlement_date(self, table_data):
        """Finds the date of the last settled transaction from the provided data.

        Args:
            table_data (list): List of transaction rows.

        Returns:
            datetime.date or None: Date of the last settlement or None if no settlements found.
        """
        last_settlement_date = None
        last_settlement_id = -1
        for row in reversed(table_data):  # Iterate in reverse to find the last settlement quickly 
            if row[5] == '0': 
                last_settlement_date = datetime.datetime.strptime(row[1], "%Y-%m-%d").date()
                last_settlement_id = row[0]
                break
        return last_settlement_date , last_settlement_id

    def make_table_items(self, column_list, table_data):
        updated_column_list = []
        updated_table_data = []
        for i in column_list:
            updated_column_list.append(i[1])

        if len(column_list) != 10:
            updated_table_data = table_data
            column_width_list = [1,1,1,1,400,1]
            if __name__ != "__main__":
                table_id = self.table_dropdown.get().split()[0]
                item_name = inventory.get_item_by_id(table_id)[1]
                item_instock = inventory.get_item_quantity(table_id)
                status = f"{item_name}   [{item_instock}] "
                self.master.master.set_status(status)
        else:
            column_width_list = [10,200,1,1,1,1,1,1,1,1,1,1]
            updated_column_list.append("In Stock")
            updated_column_list.append("Total Value")
            # updated_column_list.append("Stock Value")
            # updated_column_list.append("Last Value")
            all_items_stock_value = 0.0
            for row in table_data:
                # print(row)
                item_id = int(row[0])
                temp_list = []
                for i in row:
                    temp_list.append(i)

                in_stock = inventory.get_item_quantity(item_id)
                total_stock_value = round(in_stock * float(row[3]), 2)
                all_items_stock_value += total_stock_value
                # total_stock_value = inventory.get_item_value(item_id)
                # last_value = inventory.get_last_value(item_id)
                temp_list.append(in_stock)
                temp_list.append(total_stock_value)
                # temp_list.append(total_stock_value)
                # temp_list.append(last_value)
                updated_table_data.append(temp_list)
            if __name__ != "__main__":
                status = f"{all_items_stock_value} "
                self.master.master.set_status(status)

            

        return updated_column_list, updated_table_data, column_width_list

    def export_to_excel(self):
        """Exports the Treeview data to an Excel file and asks the user if they want to open it."""
        try:
            # Get data from Treeview
            data = []
            for item in self.tree.get_children():
                row = self.tree.item(item)['values']
                data.append(row)

            # Get column names from Treeview
            column_names = self.tree["columns"]

            # Create a new workbook and worksheet
            workbook = openpyxl.Workbook()
            worksheet = workbook.active

            # Write the header row
            worksheet.append(column_names)

            # Write the data rows
            for row in data:
                worksheet.append(row)

            # Get filename using a file dialog
            file_name = filedialog.asksaveasfilename(
                defaultextension=".xlsx",
                filetypes=[("Excel files", "*.xlsx"), ("All files", "*.*")],
                initialdir="C:/JBBExcel",
                initialfile = 'temp',
                confirmoverwrite = False,
                title="Save Report as Excel"
                
            )

            if file_name:
                # Save the workbook
                workbook.save(file_name)

                if __name__ != "__main__":
                    self.master.master.set_status(f"Data exported to {file_name}")

                # Ask the user if they want to open the file
                if messagebox.askyesno("Open File", "Do you want to open the exported Excel file?"):
                    os.startfile(file_name)  # Open for Windows
            else:
                if __name__ != "__main__":
                    self.master.master.set_status("Export cancelled")

        except Exception as e:
            if __name__ != "__main__":
                self.master.master.set_status(f"Error exporting to Excel: {e}")
            print(f"Error exporting to Excel: {e}")

    def tree_subtree_accounts(self, account_id):
        selected_table = f"customer_{account_id}"
        accounts.accounts_cursor.execute(f"PRAGMA table_info({selected_table})")
        column_list = accounts.accounts_cursor.fetchall()
        table_data = accounts.get_table(selected_table)
        column_names, table_data, column_width_list = self.make_table_accounts(column_list, table_data)
        return table_data
                


if __name__ == "__main__":
    app = tk.Tk()
    app.state("zoomed")
    h = ReportsPage(app)
    h.pack(expand=1, fill="both")
    # h.calculate_total123()
    app.mainloop()


 
import tkinter as tk
import tkinter.ttk as ttk
import re
from .mytheme import Colors
from datetime import datetime
from .searchbar import SearchBar

from database import accounts, inventory, database
# import accounts
# import inventory
# import database

class SalesPage(tk.Frame):
    def __init__(self, master, **kwargs):
        super().__init__(master, **kwargs)

        # main frame to include all frames
        self.main_frame = tk.Frame(self, bg=Colors.BACKGROUND)
        self.main_frame.place(relx=0.3, rely=0.01, relwidth=.4, relheight=.98)

        # title frame
        title_name_label = tk.Label(self.main_frame, text="Sales", font="Consolas 18", bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_3, anchor='center')
        title_name_label.pack(pady=10, fill='x')

        # Date Entry Box
        date_label = tk.Label(self.main_frame, text="Date", font="Consolas 12", bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND, anchor='w')
        date_label.pack(padx=40, fill='x')
        today_date = tk.StringVar(value=datetime.now().strftime('%Y-%m-%d'))
        self.date_entry = tk.Entry(self.main_frame, textvariable=today_date, font="Consolas 14", bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_1, relief='solid')
        self.date_entry.pack(padx=40, pady=(0,10), fill='x')

        # Account Dropdown Menu
        account_label = tk.Label(self.main_frame, text="Account", font="Consolas 12", bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND, anchor='w')
        account_label.pack(padx=40, pady=(20,0), fill='x')
        account_choices = self.get_accounts()
        self.account_dropdown = SearchBar(self.main_frame, data=account_choices)
        self.account_dropdown.pack(padx=40, pady=(0, 10), fill='x')
        self.account_dropdown.search_bar.bind('<Enter>', lambda e: self.account_dropdown.set_data(self.get_accounts()))

        # Item Dropdown Menu
        item_label = tk.Label(self.main_frame, text="Item", font="Consolas 12", bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND, anchor='w')
        item_label.pack(padx=40, pady=(20, 0), fill='x')
        self.item_choices = self.get_items_from_inventory()
        self.item_dropdown = SearchBar(self.main_frame, data=self.item_choices)
        self.item_dropdown.pack(padx=40, pady=(0, 10), fill='x')
        self.item_dropdown.search_bar.bind('<Enter>', lambda e: self.item_dropdown.set_data(self.get_items_from_inventory()))
        self.item_dropdown.search_bar.bind('<FocusOut>', lambda e: self.set_price())

        # Quantity Entry Box
        quantity_label = tk.Label(self.main_frame, text="Quantity", font="Consolas 12", bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND, anchor='w')
        quantity_label.pack(padx=40, pady=(20,0), fill='x')
        self.quantity_entry = tk.Entry(self.main_frame, font="Consolas 14", bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_1, relief='solid')
        self.quantity_entry.pack(padx=40, pady=(0, 10), fill='x')

        # Price Entry Box
        price_label = tk.Label(self.main_frame, text="Price", font="Consolas 12", bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND, anchor='w')
        price_label.pack(padx=40, pady=(20,0), fill='x')
        self.price_entry = tk.Entry(self.main_frame, font="Consolas 14", bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_1, relief='solid')
        self.price_entry.pack(padx=40, pady=(0, 10), fill='x')


        # Item Dropdown Menu
        tag_label = tk.Label(self.main_frame, text="Tag", font="Consolas 12", bg=Colors.BACKGROUND, fg=Colors.ACTIVE_FOREGROUND, anchor='w')
        tag_label.pack(padx=40, pady=(20,0), fill='x')
        tag_choices = ["0 Set Nill", "1 Normal", "2 No interest"]
        self.tag_dropdown = ttk.Combobox(self.main_frame, values=tag_choices, font="Consolas 14")
        self.tag_dropdown.pack(padx=40, pady=(0, 10), fill='x')
        self.tag_dropdown.set("1 Normal")


        # Sale recieve Button
        sale_button_frame  = tk.Frame(self.main_frame, bg=Colors.BACKGROUND)
        sale_button_frame.pack( fill='x', pady=10, padx=0)
        sale_button = tk.Button(sale_button_frame, text="Sale", font="Consolas 14", command=self.sale, bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_3, relief='solid')
        sale_button.pack(padx=(40,5), fill='x', pady=20, side='left', expand=1)
        recieve_button = tk.Button(sale_button_frame, text="Recieve", font="Consolas 14", command=self.receive, bg=Colors.BACKGROUND, fg=Colors.FG_SHADE_3, relief='solid')
        recieve_button.pack(padx=(5, 40), fill='x', pady=20, side='right', expand=1)

    def update_listbox_items(self, lb, lst, pat):
        lsts = []
        # print(lb,lst, pat)
        for i in lst:
            if re.search(pat, f"{i[0]} {i[1]}"):
                lsts.append(i)
        lb.config(values=lsts)

    def get_items_from_inventory(self):
        """Fetches items from the inventory, formatting for the search bar."""
        item_list = inventory.get_all_items()
        return [f"{i[0]} {i[1]} {i[5]}" for i in item_list]  # Format for SearchBar 

    def get_accounts(self):
        """Fetches accounts, formatting them for the search bar."""
        account_list = accounts.get_all_customers()
        return [f"{i[0]} {i[1]} {i[2]}" for i in account_list] 
    
    def set_price(self):
        self.item_dropdown.hide_listbox(1)
        item_name = self.item_dropdown.get_text()
        if item_name in self.item_choices:
            item_id = item_name.split()[0]
            last_value = inventory.get_last_value(item_id)
            self.price_entry.delete(0, tk.END) 
            self.price_entry.insert(0, last_value)

    def _get_transaction_data(self):
        """Retrieves and validates transaction data from input fields."""
        date = self.date_entry.get()
        item_name = self.item_dropdown.get_text().strip()
        account_name = self.account_dropdown.get_text()
        quantity = self.quantity_entry.get()
        price = self.price_entry.get()
        tag_value = self.tag_dropdown.get()

        if not all([date, item_name, account_name, quantity, price, tag_value]):
            return None  # Indicate missing data 

        item_exists = self._check_item_exists(item_name)
        if item_exists:
            item_id, iname = item_name.split(" ", 1) # Split and unpack
            item_id = int(item_id)
        else:
            item_id = -1
            iname = item_name
        account_id, aname = account_name.split(" ", 1)
        account_id = int(account_id)

        tagint = int(tag_value[0])  # Convert to integer
        amount = float(price) * float(quantity)
        detail = f"{quantity} = {iname}"

        return date, item_id, account_id, iname, aname, quantity, price, tagint, amount, detail

    def _process_transaction(self, transaction_type): 
        """Processes sales (P) or receive (M) transactions."""

        data = self._get_transaction_data()
        if data is None:
            if __name__ != "__main__":
                self.master.master.set_status("[-]|Some fields are empty|")
            return 

        date, item_id, account_id, iname, aname, quantity, price, tagint, amount, detail = data

        if tagint == 0:
            self._handle_settlement(account_id, date, detail, amount, transaction_type) 
        else:
            accounts.add_customer_transaction(account_id, date, detail, amount, transaction_type, tagint)

        if item_id != -1:  # Update inventory only if the item exists
            inventory.add_item_transaction(item_id, date,
                                        int(float(quantity)) if transaction_type == "M" else 0,
                                        int(float(quantity)) if transaction_type == "P" else 0,
                                        aname)
            inventory.set_last_value(item_id, int(price)) 

        note_id = self._add_daily_note(date, iname, aname, quantity, price, tagint, transaction_type)

        if __name__ != "__main__":
            if item_id == -1:
                self.master.master.set_status(f"Success (inventory may not be updated). Note ID: {note_id}")
            else:
                self.master.master.set_status(f"Success! Note ID: {note_id}")


    def _handle_settlement(self, account_id, date, detail, amount, transaction_type):
        """Handles account settlements (Tag = 0)."""
        total_amount = accounts.get_account_balance(account_id)  # Before adding new transaction
        discount = total_amount + amount if transaction_type == "P" else (total_amount - amount) 

        accounts.add_customer_transaction(account_id, date, detail, amount, transaction_type, 0) # original transaction
        accounts.add_customer_transaction(account_id, date, "Settled Amount", total_amount, "M" , 0)  # record settled amount 
        accounts.add_customer_transaction(account_id, date, "Discount", discount, "M", 0)  # record discount (if any)

    def _check_item_exists(self, item_name):
        """Checks if the complete item string exists in the choices."""
        return item_name in self.item_choices  


    def _add_daily_note(self, date, iname, aname, quantity, price, tagint, transaction_type):
        """Adds a note to the daily_notes database."""
        note = (
            f"03 = {date}, {iname}, {aname}, {quantity}, {price}, {tagint}"
            if transaction_type == "P" 
            else f"04 = {date}, {iname}, {aname}, {quantity}, {price}, {tagint}"
        )
        return database.add_note_to_date(note)

    def sale(self):
        """Handles sale transactions."""
        self._process_transaction("P")

    def receive(self):
        """Handles receive transactions."""
        self._process_transaction("M") 
            


if __name__ == "__main__":
    app = tk.Tk()
    app.state("zoomed")
    h = SalesPage(app)
    h.pack(expand=1, fill="both")
    app.mainloop()

 
import tkinter as tk
import tkinter.font as tkfont
from .mytheme import Colors

class SearchBar(tk.Frame):
    def __init__(self, master, data, **kwargs):
        super().__init__(master, **kwargs)

        self.data = data

        # Search Bar
        self.text_variable = tk.StringVar()  # Text variable
        self.search_bar = tk.Entry(self, textvariable=self.text_variable, 
                                    font="Consolas 14",
                                    borderwidth=0,
                                    # relief="groove",
                                    background=Colors.BACKGROUND,
                                    fg=Colors.FG_SHADE_1,
                                    highlightthickness=2,
                                    highlightbackground=Colors.BG_SHADE_2,
                                    highlightcolor=Colors.ACTIVE_FOREGROUND
                                    )
        self.search_bar.pack(fill='both', expand=True)
        self.search_bar.bind("<KeyRelease>", self.search)
        self.search_bar.bind("<Down>", self.focus_listbox)
        self.search_bar.bind("<FocusOut>", self.hide_listbox)
        self.highlight_border_color = self.search_bar.cget("highlightbackground")
        self.default_border_color = self.search_bar.cget("highlightcolor")

        # Suggestion Listbox (in a Toplevel)
        self.suggestion_toplevel = None
        self.suggestion_listbox = None

        self.current_suggestion_index = -1

    def search(self, event):
        if event.keysym == "Return":  # Ignore Enter key
            return

        search_term = self.search_bar.get().lower()
        suggestions = self.get_suggestions(search_term)

        if suggestions:
            if self.suggestion_toplevel is None:
                self.suggestion_toplevel = tk.Toplevel(self)
                self.suggestion_toplevel.wm_overrideredirect(True)
                self.suggestion_toplevel.wm_geometry("+%d+%d" % (
                    self.search_bar.winfo_rootx(),
                    self.search_bar.winfo_rooty() + self.search_bar.winfo_height()
                ))
                entry_font = tkfont.Font(font=self.search_bar.cget("font"))
                char_width = entry_font.measure("0")
                listbox_width_chars = int(self.search_bar.winfo_width() / (char_width+1 ))

                self.suggestion_listbox = tk.Listbox(
                    self.suggestion_toplevel,
                    width=listbox_width_chars,
                    font=entry_font.actual(),
                    bg=Colors.BACKGROUND,
                    fg=Colors.FG_SHADE_1,
                    bd=1,
                    highlightthickness=0,
                    selectbackground=Colors.ACTIVE_BACKGROUND,
                    selectforeground=Colors.FOREGROUND,
                    activestyle="none",
                    relief='flat'
                )
                self.suggestion_listbox.pack(fill='both', expand=True)
                self.suggestion_listbox.bind("<FocusOut>", self.hide_listbox)
                self.suggestion_listbox.bind("<Return>", self.select_suggestion)
                self.suggestion_listbox.bind("<Up>", self.navigate_listbox)
                self.suggestion_listbox.bind("<Down>", self.navigate_listbox)

                max_height = 6
                listbox_height = min(len(suggestions), max_height)
                self.suggestion_listbox.config(height=listbox_height)

            self.suggestion_listbox.delete(0, tk.END)
            max_height = 6
            listbox_height = min(len(suggestions), max_height)
            self.suggestion_listbox.config(height=listbox_height)
            for suggestion in suggestions:
                self.suggestion_listbox.insert(tk.END, suggestion)
            self.current_suggestion_index = -1
            self.search_bar.config(highlightbackground=self.highlight_border_color)
            self.search_bar.config(highlightcolor=self.default_border_color)
        else:
            self.hide_listbox(None)  # Hide if no suggestions
            self.search_bar.config(highlightbackground="red")
            self.search_bar.config(highlightcolor="red")

    def get_suggestions(self, search_term):
        suggestions = [item for item in self.data if search_term in item.lower()]
        return suggestions

    def focus_listbox(self, event):
        if self.suggestion_listbox and self.suggestion_listbox.winfo_ismapped():
            self.suggestion_listbox.focus()
            self.suggestion_listbox.selection_set(0)
            self.current_suggestion_index = 0

    def hide_listbox(self, event):
        if self.suggestion_toplevel:
            focused_widget = self.focus_get()
            if focused_widget != self.suggestion_listbox and focused_widget != self.search_bar:
                self.suggestion_toplevel.destroy()
                self.suggestion_toplevel = None
                self.suggestion_listbox = None

    def select_suggestion(self, event):
        selection = self.suggestion_listbox.curselection()
        if selection:
            choice = self.suggestion_listbox.get(selection[0])
            self.search_bar.delete(0, tk.END)
            self.search_bar.insert(0, choice)
            self.hide_listbox(None)

            self.search_bar.focus_set()

    def navigate_listbox(self, event):
        if self.suggestion_listbox:
            size = self.suggestion_listbox.size()
            if event.keysym == "Up":
                self.current_suggestion_index = max(0, self.current_suggestion_index - 1)
            elif event.keysym == "Down":
                self.current_suggestion_index = min(size - 1, self.current_suggestion_index + 1)
            self.suggestion_listbox.selection_clear(0, tk.END)
            self.suggestion_listbox.selection_set(self.current_suggestion_index)
            self.suggestion_listbox.see(self.current_suggestion_index)

    def get_text(self):
        return self.search_bar.get()

    def set_text(self, text):
        self.text_variable.set(text)

    def set_data(self, data):
        self.data = data


if __name__ == "__main__":
    app = tk.Tk()
    app.geometry("400x300")
    app.config(background='#dddddd')

    data = ["apple", "banana", "cherry", "grape", "orange", "watermelon", "sdiuo ho "]

    entry1 = SearchBar(app, data)
    entry1.pack(pady=20, padx=20, fill='x')

    entry2 = SearchBar(app, data)
    entry2.pack(pady=20, padx=20, fill='x')

    app.mainloop()
 

 
import os

def get_python_files(path):
  """
  Get all Python files in a directory and its subdirectories.

  Args:
    path: The starting directory path.

  Yields:
    Full paths to all Python files found.
  """
  for root, _, files in os.walk(path):
    for filename in files:
      if filename.endswith(".py"):
        yield os.path.join(root, filename)

def save_code_to_file(filepaths, output_filename):
  """
  Saves the code from all Python files to a single output file.

  Args:
    filepaths: A list of file paths to Python files.
    output_filename: The name of the file to save the code to.
  """
  with open(output_filename, 'w') as output_file:
    for filepath in filepaths:
      with open(filepath, 'r') as input_file:
        print(filepath)
        if "bill" not in filepath:

            output_file.write(input_file.read() + "\n \n")

if __name__ == "__main__":
  # Get the current working directory
  cwd = os.getcwd()

  # Get all Python files in the current directory and subdirectories
  python_files = get_python_files(cwd)

  # Save the code to a file named output.txt
  save_code_to_file(python_files, "output.txt")

  print("Python code saved to output.txt")

 

 

 
